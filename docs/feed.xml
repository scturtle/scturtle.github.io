<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>turtleblog</title>
  <link href="https://scturtle.me/" />
  <link href="https://scturtle.me/feed.xml" rel="self" type="application/atom+xml" />
  <generator>Hugo -- gohugo.io</generator>
  <updated>2023-12-22T17:24:52+08:00</updated>
  <id>https://scturtle.me/</id>
  
  <entry>
    <title type="html"><![CDATA[Static Single Assignment]]></title>
    <link href="https://scturtle.me/posts/2022-11-26-ssa.html" />
    <published>2022-11-26T08:00:00+08:00</published>
    <updated>2022-11-26T08:00:00+08:00</updated>
    <id>https://scturtle.me/posts/2022-11-26-ssa.html</id>
    <content type="html"><![CDATA[<h1 id="cfg">CFG</h1>
<p>抄维基一个例子，如下一段代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x = 5
</span></span><span style="display:flex;"><span>x = x - 3
</span></span><span style="display:flex;"><span><span style="font-weight:bold">if</span> x &lt; 3:
</span></span><span style="display:flex;"><span>    y = x * 2
</span></span><span style="display:flex;"><span>    w = y
</span></span><span style="display:flex;"><span><span style="font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>    y = x - 3
</span></span><span style="display:flex;"><span>w = x - y
</span></span><span style="display:flex;"><span>z = x + y
</span></span></code></pre></div><p>可以转换为 control-flow graph：</p>
<pre class="mermaid">flowchart TD
    A[x = 5\nx = x - 3\nx < 3?]
    B[y = x * 2\nw = y]
    C[y = x - 3]
    D[w = x - y\nz = x + y]
    entry --> A
    A --> B
    A --> C
    B --> D
    C --> D
</pre>

<h1 id="ssa">SSA</h1>
<p>SSA (static single assignment) 形式的含义是 IR 里每个变量仅被赋值一次。</p>
<p>最简单的办法是给每一个变量加一个后缀，变成一个新的变量：</p>
<pre class="mermaid">flowchart TD
    A[x1 = 5\nx2 = x1 - 3\nx2 < 3?]
    B[y1 = x2 * 2\nw1 = y1]
    C[y2 = x2 - 3]
    D["y3 = Φ(y1, y2)\nw2 = x2 - y3\nz1 = x2 + y3"]
    entry --> A
    A --> B
    A --> C
    B --> D
    C --> D
</pre>

<p>为了解决 node 汇入时该使用哪一个变量的问题，引入了 Φ(phi)-function。含义是从第几个前驱 node 来的话就取第几个参数变量。</p>
<p>如果 <code>y2 = x2 - 3</code> 这个 node 里的 <code>y2</code> 使用 <code>y1</code> 的名字的话，最后一个 block  可以只用 <code>y1</code> 也就避免了插入 Φ，得到了更简单的表示。</p>
<p>如何得到 minimal SSA 需要引入 dominator tree。</p>
<h1 id="dominator-tree">dominator tree</h1>
<p>回到最初的 CFG：</p>
<pre class="mermaid">flowchart TD
    A[A:\nx = 5\nx = x - 3\nx < 3?]
    B[B:\ny = x * 2\nw = y]
    C[C:\ny = x - 3]
    D[D:\nw = x - y\nz = x + y]
    entry --> A
    A --> B
    A --> C
    B --> D
    C --> D
</pre>

<p>如果从 entry 到 node Y 的每一条路径都经过了 node X 的话，我们就说 X dominate 了 Y。（后面简写为 <code>X dom Y</code>。）</p>
<p>Domination 具有自反性（<code>X dom X</code>）和传递性（<code>X dom Y, Y dom Z =&gt; X dom Z</code>）。</p>
<p>也可以说 X 是 Y 的 dominator。Y 的 dominator 组成集合 <code>dom(Y)</code>。</p>
<p>如上图，<code>dom(A) = {A}</code>，<code>dom(B) = {A, B}</code>，<code>dom(C) = {A, C}</code>。</p>
<p>用集合也可以给出递归定义：</p>
<pre tabindex="0"><code>dom(Y) = ∩(dom(X) for X in preds(Y)) ∪ {Y}
</code></pre><p>Y 的 immediate dominator，简写为 <code>idom(Y)</code>，是指非 Y 但离 Y 最近的 dominator。</p>
<p>可以证明 <code>idom(Y)</code> 最多只有一个。那么 <code>idom</code> 关系可以组成一颗 dominator tree。</p>
<p><code>dom(Y)</code> 集合的定义也可以反过来用 <code>idom</code> 表示：</p>
<pre tabindex="0"><code>dom(Y) = {Y} ∪ {idom(Y)} ∪ {idom(idom(Y))} ··· ∪ {E}
</code></pre><h1 id="dominance-frontier">dominance frontier</h1>
<p>简写为 <code>DF(X)</code>，可以理解为那些 <em>恰好</em> 不再受 X dominate 的 node 的集合。</p>
<p>比如 X dom 了 Z 的一个前驱 Y，但 Z 还有别的没有被 X dom 的前驱，导致 X 并没有 dom Z，那么 Z 就属于 <code>DF(X)</code>。</p>
<p>可以看出 dominance frontier 是单个变量的不同定义在 CFG 中交汇的地方，是插入 Φ-function 的理想地方。</p>
<p>但插入 Φ-function 其实又算是一次变量定义。所以通常会先求一个 iterated dominance frontier（设 <code>defs(v)</code> 是定义了变量 <code>v</code> 的 nodes）：</p>
<pre tabindex="0"><code>DF+(v) = DF(defs(v)) u DF(DF(defs(v))) u DF(DF(DF(defs(v)))) ...
</code></pre><p>也叫做 <code>joins(v)</code>。</p>
<h1 id="reverse-postorder">Reverse postorder</h1>
<p>顾名思义，就是把后续遍历得到的顺序反序一下。相当于 CFG 这种有向有环图上的拓扑序。</p>
<p>按照该顺序来遍历 CFG 中的 node，可以保证在遍历 node 前已经遍历完它的 dominators  了。所以后文算法中遍历 node 的顺序通常指该顺序。</p>
<h1 id="dominance-algorithm">Dominance algorithm</h1>
<p>根据前面定义，一个 naive 的求 dominator 集合的迭代算法可以用伪代码表示为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="font-weight:bold">for</span> n <span style="font-weight:bold">in</span> nodes:
</span></span><span style="display:flex;"><span>    dom[n] = {1 ... N}
</span></span><span style="display:flex;"><span>changed = <span style="font-weight:bold">True</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">while</span> changed:
</span></span><span style="display:flex;"><span>    changed = <span style="font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> n <span style="font-weight:bold">in</span> nodes:
</span></span><span style="display:flex;"><span>        new_dom = <span style="">∩</span>(dom[p] <span style="font-weight:bold">for</span> p <span style="font-weight:bold">in</span> preds[n]) <span style="">∪</span> {n}
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> new_dom != dom[n]:
</span></span><span style="display:flex;"><span>            dom[n] = new_dom
</span></span><span style="display:flex;"><span>            changed = <span style="font-weight:bold">True</span>
</span></span></code></pre></div><p>因为 <code>dom(...)</code> 集合可以看做是 dominator tree 上沿着 <code>idom[...]</code> 的向上递归到 entry 一条路径，那么 <code>dom(A) ∩ dom(B)</code> 就是路径的的共同前缀。</p>
<p>用 <code>idom</code> 数组来替代集合的话，求并集变成了求两条路径的最近公共祖先：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="font-weight:bold">def</span> intersect(a, b):
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">while</span> a != b:
</span></span><span style="display:flex;"><span>        a_idx = get_reverse_postorder_index(a)
</span></span><span style="display:flex;"><span>        b_idx = get_reverse_postorder_index(b)
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> a_idx &lt; b_idx:
</span></span><span style="display:flex;"><span>            b = idom[b]
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">else</span>:
</span></span><span style="display:flex;"><span>            a = idom[a]
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> a
</span></span></code></pre></div><p>原算法可以简化为求 <code>idom[...]</code> 也即 dominator tree 的算法：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="font-weight:bold">for</span> n <span style="font-weight:bold">in</span> nodes:
</span></span><span style="display:flex;"><span>    idom[n] = <span style="font-weight:bold">None</span>
</span></span><span style="display:flex;"><span>idom[entry] = entry
</span></span><span style="display:flex;"><span>changed = <span style="font-weight:bold">True</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">while</span> changed:
</span></span><span style="display:flex;"><span>    changed = <span style="font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> n <span style="font-weight:bold">in</span> nodes:
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> n == entry:
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">continue</span>
</span></span><span style="display:flex;"><span>        new_idom = pred[n][0]  <span style="font-style:italic"># pick first predecessor</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span> p <span style="font-weight:bold">in</span> pred[n][1:]:  <span style="font-style:italic"># rest predecessors</span>
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">if</span> idom[n] != <span style="font-weight:bold">None</span>:
</span></span><span style="display:flex;"><span>                new_idom = intersect(new_idom, idom[p])
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> idom[n] != new_idom:
</span></span><span style="display:flex;"><span>            idom[n] = new_idom
</span></span><span style="display:flex;"><span>            changed = <span style="font-weight:bold">True</span>
</span></span></code></pre></div><p>有了 dominator tree 之后求 dominance frontier 也很简单。在交汇点 <code>n</code> 和 <code>idom[n]</code> 之间所有节点，都有 <code>n</code> 作为其 dominance frontier 的一员：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="font-weight:bold">for</span> n <span style="font-weight:bold">in</span> nodes:
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> len(preds[n]) &gt;= 2:  <span style="font-style:italic"># is a join point</span>
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span> p <span style="font-weight:bold">in</span> preds[n]:
</span></span><span style="display:flex;"><span>            runner = p
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">while</span> runner != idom[n]:
</span></span><span style="display:flex;"><span>                df[runner].add(n)  <span style="font-style:italic"># may dup</span>
</span></span><span style="display:flex;"><span>                runner = idom[runner]
</span></span></code></pre></div><p>这就是 <a href="https://www.cs.rice.edu/~keith/Embed/dom.pdf">《A Simple, Fast Dominance Algorithm》</a> 中提出的算法。</p>
<h1 id="φ-function-insertion-and-variable-renaming">φ-function insertion and variable renaming</h1>
<p>每一个变量 v 用 dominance frontier 求 <code>joins(v)</code>，顺便插入 Φ-function：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="font-weight:bold">for</span> v <span style="font-weight:bold">in</span> variables:
</span></span><span style="display:flex;"><span>    saw = {}     <span style="font-style:italic"># blocks where Φ is added</span>
</span></span><span style="display:flex;"><span>    w = queue()  <span style="font-style:italic"># working list</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> n <span style="font-weight:bold">in</span> defs[v]:
</span></span><span style="display:flex;"><span>        w.push(n)
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">while</span> w:
</span></span><span style="display:flex;"><span>        x = w.pop()
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">for</span> y <span style="font-weight:bold">in</span> df[x]:
</span></span><span style="display:flex;"><span>            <span style="font-weight:bold">if</span> y <span style="font-weight:bold">not</span> <span style="font-weight:bold">in</span> saw:
</span></span><span style="display:flex;"><span>                add v = Φ(...) at start of y
</span></span><span style="display:flex;"><span>                saw.add(y)
</span></span><span style="display:flex;"><span>                <span style="font-weight:bold">if</span> y <span style="font-weight:bold">not</span> <span style="font-weight:bold">in</span> defs[v]:
</span></span><span style="display:flex;"><span>                    w.push(y)
</span></span></code></pre></div><p>这时变量名还都是原变量名，还不是 SSA，需要做一次 variable renaming。</p>
<p>做法是从 entry 递归向下，一边改新变量名，一边顺便记住最后使用的新变量名，以便后续节点做替换：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="font-weight:bold">def</span> ssa_rename_rec(node, last):
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span> node <span style="font-weight:bold">is</span> <span style="font-weight:bold">in</span> saw:
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">continue</span>
</span></span><span style="display:flex;"><span>    saw.add(node)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> inst <span style="font-weight:bold">in</span> node:  <span style="font-style:italic"># for each instruction in node</span>
</span></span><span style="display:flex;"><span>        replace every var used <span style="font-weight:bold">in</span> inst <span style="font-weight:bold">with</span> last[var]
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> inst defined var:  <span style="font-style:italic"># maybe store inst or Φ-function</span>
</span></span><span style="display:flex;"><span>            create <span style="font-weight:bold">and</span> replace <span style="font-weight:bold">with</span> new_var name
</span></span><span style="display:flex;"><span>            last[var] = new_var
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> child of node <span style="font-weight:bold">in</span> dominator tree:
</span></span><span style="display:flex;"><span>        <span style="font-style:italic"># child is immediately dominated by this node</span>
</span></span><span style="display:flex;"><span>        ssa_rename_rec(child, copy(last))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ssa_rename_rec(entry)
</span></span></code></pre></div><h1 id="application">Application</h1>
<p><a href="https://zenodo.org/record/3736363">《Bringing GNU Emacs to Native Code》</a> 就用到了以上的算法。</p>
<p>可以在 <a href="https://github.com/emacs-mirror/emacs/blob/0369dcacf30aff6d4f733872058fa2446330fd02/lisp/emacs-lisp/comp.el">这里</a> 看到整套算法的 lisp 实现。</p>
<h1 id="reference">Reference</h1>
<p><a href="https://www.cs.utexas.edu/~pingali/CS380C/2010/papers/ssaCytron.pdf">《Efficiently computing static single assignment form and the control dependence graph》</a></p>
<p><a href="https://pfalcon.github.io/ssabook/latest/book-full.pdf">《Static Single Assignment Book》</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《Software Engineering at Google》笔记]]></title>
    <link href="https://scturtle.me/posts/2022-03-05-swe-at-google.html" />
    <published>2022-03-05T08:00:00+08:00</published>
    <updated>2022-03-05T08:00:00+08:00</updated>
    <id>https://scturtle.me/posts/2022-03-05-swe-at-google.html</id>
    <content type="html"><![CDATA[<h1 id="o-前言">O. 前言</h1>
<blockquote>
<p>The great thing about tech is that there is never only one way to do something. Instead, there is a series of trade-offs we all must make depending on the circumstan‐ ces of our team and situation.
技术的伟大之处在于，做一件事从来没有唯一的方法。相反，我们必须根据我们的团队和处境来做一系列的权衡。</p>
</blockquote>
<blockquote>
<p>Of course, Google is a unique company, and it would be foolish to assume that the right way to run your software engineering organization is to precisely copy their formula.
当然，谷歌是一家独特的公司，如果认为运行你的软件工程组织的正确方法是精确地复制他们的公式，那就太愚蠢了。</p>
</blockquote>
<h1 id="i-理论">I. 理论</h1>
<h2 id="1-什么是软件工程">1. 什么是软件工程</h2>
<blockquote>
<p>Within Google, we sometimes say, “Software engineering is programming integrated over time.”
在谷歌，我们有时会说，&ldquo;软件工程是对时间积分的编程&rdquo;。</p>
</blockquote>
<blockquote>
<p>Software engineering is the set of policies, practices, and tools that are necessary to make that code useful for as long as it needs to be used and allowing collaboration across a team.
软件工程是一套必要的政策、实践和工具，以使这些代码在需要使用的时间内发挥作用，并允许整个团队的协作。</p>
</blockquote>
<blockquote>
<p>Your project is <strong>sustainable</strong> if, for the expected life span of your software, you are capable of reacting to whatever valuable change comes along, for either technical or business reasons.
如果在软件的预期寿命内，你有能力对由于技术或商业原因而出现的任何有价值的变化做出反应，你的项目就是<strong>可持续的</strong>。</p>
</blockquote>
<p>衡量代码的预期寿命做不同的选择。</p>
<blockquote>
<p>Hyrum’s Law: With a sufficient number of users of an API, it does not matter what you promise in the contract: all observable behaviors of your system will be depended on by somebody.
海勒姆法则：当一个API的用户数量足够多时，你在合同中承诺什么并不重要，你的系统的所有可观察到的行为都会被某人所依赖。</p>
</blockquote>
<blockquote>
<p>“It’s program‐ ming if ‘clever’ is a compliment, but it’s software engineering if ‘clever’ is an accusation.”
&ldquo;如果&rsquo;聪明&rsquo;是一种赞美，那就是编程，但如果&rsquo;聪明&rsquo;是一种指责，那就是软件工程。&rdquo;</p>
</blockquote>
<blockquote>
<p>The health of an organization isn’t just whether there is money in the bank, it’s also whether its members are feeling valued and productive.
一个组织的健康不仅仅是银行里是否有钱，还包括其成员是否感觉到被重视和亲和力。</p>
</blockquote>
<h1 id="ii-文化">II. 文化</h1>
<h2 id="2-团队工作">2. 团队工作</h2>
<blockquote>
<p>The Three Pillars of Social Interaction: <strong>humility, respect, trust</strong>.
社会交往的三大支柱：<strong>谦逊、尊重、信任</strong>。</p>
</blockquote>
<p>Insecurity. 不安全感。</p>
<p>Genius Myth. 天才神话。</p>
<blockquote>
<p>Being a genius is most definitely not an excuse for being a jerk: anyone—genius or not—with poor social skills tends to be a poor teammate. The vast majority of the work at Google (and at most companies!) doesn’t require genius-level intellect, but 100% of the work requires a minimal level of social skills. What will make or break your career, especially at a company like Google, is how well you collaborate with others.
作为一个天才，绝对不是成为一个混蛋的借口：任何一个人&ndash;无论是否是天才&ndash;如果社交能力差，往往会成为一个糟糕的团队伙伴。在谷歌（以及大多数公司！），绝大多数工作都不需要天才级别的智力，但100%的工作都需要最低水平的社交技能。决定你职业生涯成败的，尤其是在谷歌这样的公司，是你与他人合作的程度。</p>
</blockquote>
<p>Hiding considered harmful.</p>
<blockquote>
<p>Bus factor: the number of people that need to get hit by a bus before your project is completely doomed.
公交车因子：在你的项目完全失败之前，需要被公交车撞到的人数。</p>
</blockquote>
<blockquote>
<p>In the same way, your self-worth shouldn’t be connected to the code you write—or any creative project you build. To repeat ourselves: you are not your code. Say that over and over. You are not what you make. You need to not only believe it yourself, but get your coworkers to believe it, too.
同样，你的自我价值不应该与你写的代码&ndash;或你建立的任何创造性项目相联系。重复我们的观点：你不是你的代码。反复说这句话。你不是你做的东西。你不仅要自己相信这一点，还要让你的同事也相信这一点。</p>
</blockquote>
<blockquote>
<p>At Google, one of our favorite mottos is that “Failure is an option.”
在谷歌，我们最喜欢的格言之一是：&ldquo;失败是一种选择&rdquo;。</p>
</blockquote>
<p>Blameless post-mortem culture.</p>
<h2 id="3-知识传播">3. 知识传播</h2>
<blockquote>
<p>Single point of failure (SPOF): A bottleneck that occurs when critical information is available from only a single person.
单点故障 (SPOF)：当关键信息只能从一个人那里获得时，就会出现瓶颈。</p>
</blockquote>
<blockquote>
<p>Haunted graveyards: Places, often in code, that people avoid touching or changing because they are afraid that something might go wrong.
闹鬼的坟场：场所，通常是代码，人们避免接触或改变，因为他们担心会出问题。</p>
</blockquote>
<blockquote>
<p><strong>Psychological safety</strong> is critical to promoting a learning environment. … An enormous part of learning is being able to try things and feeling safe to fail. In a healthy environment, people feel comfortable asking questions, being wrong, and learning new things.
<strong>心理安全</strong>是促进学习环境的关键。&hellip;&hellip;学习的一个重要部分是能够尝试事物，并感觉到失败的安全。在一个健康的环境中，人们对提出问题、犯错和学习新事物感到很舒服。</p>
</blockquote>
<blockquote>
<p>Impostor syndrome is not uncommon among high achievers, and Googlers are no exception—in fact, a majority of this book’s authors have impostor syndrome. We acknowledge that fear of failure can be difficult for those with impostor syndrome and can reinforce an inclination to avoid branching out.
冒名顶替综合症在高成就者中并不少见，Googlers也不例外&ndash;事实上，本书的大部分作者都有冒名顶替综合症。我们承认，对失败的恐惧对那些有冒名顶替综合症的人来说是很困难的，并且会加强避免分支的倾向。</p>
</blockquote>
<blockquote>
<p>Consider the principle of “Chesterson’s fence”: before removing or changing something, first understand why it’s there.
For the sake of simplicity, a fence or gate erected across a road. The more modern type of reformer goes gaily up to it and says, “I don’t see the use of this; let us clear it away.” To which the more intelligent type of reformer will do well to answer: “If you don’t see the use of it, I certainly won’t let you clear it away. Go away and think. Then, when you can come back and tell me that you do see the use of it, I may allow you to destroy it.”
考虑一下 &ldquo;Chesterson&rsquo;s fence &ldquo;的原则：在移除或改变某些东西之前，首先要了解它为什么在那里。
为了简单起见，让我们说，在一条道路上竖起了栅栏或大门。比较现代的改革者高高兴兴地走到它面前，说：&ldquo;我不知道这有什么用；让我们把它清除掉。&rdquo; 对此，更聪明的改革者会很好地回答。&ldquo;如果你看不到它的用处，我当然不会让你清除它。走吧，好好想想。然后，当你能回来告诉我你确实看到了它的用途时，我可能会允许你销毁它。&rdquo;</p>
</blockquote>
<p>Different forms of community-based learning: group chats, mailing lists, and question-and-answer systems.</p>
<blockquote>
<p>In Google’s early days, Craig Silverstein (employee ID #3) would sit down in person with every new hire and do a line-by-line “readability review” of their first major code commit.
在谷歌的早期，克雷格-西尔弗斯坦（雇员编号3）会和每个新雇员坐下来，对他们的第一次主要代码提交进行逐行的 &ldquo;可读性审查&rdquo;。</p>
</blockquote>
<h2 id="4-equity--diversity">4. Equity &amp; Diversity</h2>
<p>略。</p>
<h2 id="5-领导力">5. 领导力</h2>
<blockquote>
<p>At Google, we recognize two different leader‐ ship roles. A Manager is a leader of people, whereas a Tech Lead leads technology efforts.
在谷歌，我们承认两种不同的领导角色。经理是人的领导者，而技术负责人则领导技术工作。</p>
</blockquote>
<blockquote>
<p>Most TLs are also individual contributors, which often forces them to choose between doing something quickly themselves or delegating it to a team member to do (sometimes) more slowly.
大多数 TL 也是个人贡献者，这往往迫使他们在自己快速做某事或委托团队成员更慢地做（有时）之间做出选择。</p>
</blockquote>
<blockquote>
<p>Whether or not they’re officially appointed, someone needs to get into the driver’s seat if your product is ever going to go anywhere, and if you’re the motivated, impa‐ tient type, that person might be you. You might find yourself sucked into helping your team resolve conflicts, make decisions, and coordinate people. It happens all the time, and often by accident. Maybe you never intended to become a “leader,” but somehow it happened anyway. Some people refer to this affliction as “manageritis.”
无论他们是否被正式任命，如果你的产品要发展，就需要有人进入驾驶座，如果你是那种有动力、有影响力的人，这个人可能就是你。你可能会发现自己被吸进了帮助你的团队解决冲突、做出决定和协调人员的行列。这种情况一直在发生，而且往往是偶然发生的。也许你从未想过要成为一个 &ldquo;领导者&rdquo;，但不知何故，它还是发生了。有些人把这种痛苦称为 &ldquo;经理炎&rdquo;。</p>
</blockquote>
<blockquote>
<p>“Peter Principle,” which states that “In a hierarchy every employee tends to rise to his level of incompetence.”
&ldquo;彼得原理&rdquo;，它指出：&ldquo;在一个等级制度中，每个员工都倾向于上升到他不能胜任的水平。&rdquo;</p>
</blockquote>
<p>Servant Leadership. 仆人式领导。</p>
<blockquote>
<p>The best advice I received when I first became a manager at Google was from Steve Vinter, an engineering director at the time. He said, “Above all, resist the urge to manage.”
当我第一次在谷歌成为一名经理时，我得到的最好的建议是来自当时的工程总监史蒂夫-温特。他说：&ldquo;首先，要抵制管理的冲动&rdquo;。</p>
</blockquote>
<blockquote>
<p>The only managing that a servant leader does is to manage both the technical and social health of the team.
仆人式领导所做的唯一管理就是管理团队的技术和社会健康。</p>
</blockquote>
<p>反模式：</p>
<ul>
<li>雇用你可以推来推去的人。</li>
<li>忽略表现不佳者。</li>
<li>忽视非技术的问题。</li>
<li>成为每个人的朋友。</li>
<li>妥协聘用标准。</li>
<li>微观管理。</li>
</ul>
<blockquote>
<p>“Sometimes you get to be the tooth fairy, other times you have to be the dentist.”
&ldquo;有些时候你可以成为牙仙，有些时候你必须成为牙医&rdquo;。</p>
</blockquote>
<p>正模式：</p>
<ul>
<li>丢掉自我。</li>
<li>成为一名禅师。</li>
<li>成为催化剂。</li>
<li>消除路障。</li>
<li>成为一名教师和辅导员（mentor）。</li>
<li>设定明确的目标。</li>
<li>诚实待人。</li>
<li>跟踪幸福度。（平均分配杂事。）</li>
</ul>
<blockquote>
<p>Be kind and empathetic when delivering constructive criticism without resorting to the com‐ pliment sandwich.
在提出建设性的批评时，要有善意和同情心，不要诉诸于赞美的三明治。</p>
</blockquote>
<blockquote>
<p>Every time a decision is made, it’s like a train coming through town—when you jump in front of the train to stop it, you slow the train down and potentially annoy the engi‐ neer driving the train. A new train comes by every 15 minutes, and if you jump in front of every train, not only do you spend a lot of your time stopping trains, but even‐ tually one of the engineers driving the train is going to get mad enough to run right over you. So, although it’s OK to jump in front of some trains, pick and choose the ones you want to stop to make sure you’re stopping only the trains that really matter.
每次做出决定时，就像一列火车驶过城镇&ndash;当你跳到火车前面去阻止它时，你会使火车减速，并可能惹恼驾驶火车的工程师。每15分钟就会有一列新的火车经过，如果你在每一列火车前都跳过去，你不仅要花很多时间来阻止火车，甚至可能有一个驾驶火车的工程师会生气到从你身上碾过。因此，尽管跳到一些火车前面是可以的，但要挑选你想停的火车，以确保你只停那些真正重要的火车。</p>
</blockquote>
<p>小技巧：</p>
<ul>
<li>委托，但要弄脏自己的手。</li>
<li>寻求取代自己。</li>
<li>Know when to make waves.</li>
<li>保护你的团队免受混乱之苦。</li>
<li>为你的团队提供空中掩护。</li>
<li>当你的团队做得很好时，让他们知道。</li>
<li>It’s easy to say “yes” to something that’s easy to undo.</li>
</ul>
<blockquote>
<p>If you’ve been leading teams for a while or if you pick up a new team, one of the easiest ways to gain the team’s respect and get up to speed on what they’re doing is to get your hands dirty—usually by taking on a grungy task that no one else wants to do.
如果你已经领导了一段时间的团队，或者你接手了一个新的团队，那么获得团队的尊重和了解他们正在做的事情的最简单的方法之一就是弄脏你的手&ndash;通常是承担一个别人不愿意做的肮脏的任务。</p>
</blockquote>
<blockquote>
<p>Remember that some people prefer to just be high-performing individual contributors, and that’s OK. We’ve always been amazed at companies that take their best engineers and—against their wishes—throw these engineers into management roles. This usually subtracts a great engineer from your team and adds a subpar manager.
请记住，有些人更愿意成为高绩效的个人贡献者，这也是可以的。我们一直对一些公司感到惊讶，这些公司把他们最优秀的工程师，违背他们的意愿，把这些工程师扔到管理岗位上。这通常会从你的团队中减少一名优秀的工程师，而增加一名不合格的经理。</p>
</blockquote>
<p>Dan Pink 的关于（内在、外在）驱动力的 <a href="https://www.ted.com/talks/dan_pink_the_puzzle_of_motivation">TED 演讲</a>。</p>
<blockquote>
<p>You can increase intrinsic motivation by giving people three things: autonomy, mastery, and purpose.
你可以通过给予人们三样东西来提高内在动机：自主权、掌握权和目的性。</p>
</blockquote>
<h2 id="6-领导力规模化">6. 领导力规模化</h2>
<blockquote>
<p>That is, you’re less and less able to get into the technical or engineering details of things, and you’re being pushed to go “broad” rather than “deep.” At every step, this process is frustrating: you mourn the loss of these details, and you come to realize that your prior engineering expertise is becoming less and less relevant to your job. Instead, your effectiveness depends more than ever on your general technical intu‐ ition and ability to galvanize engineers to move in good directions.
也就是说，你要解决的问题的范围变得更大、更抽象。你逐渐被迫变得 &ldquo;更高层次&rdquo;。也就是说，你越来越无法深入了解事情的技术或工程细节，你被逼着去 &ldquo;广泛 &ldquo;而不是 &ldquo;深入&rdquo;。在每一个步骤中，这个过程都是令人沮丧的：你为这些细节的丧失感到悲哀，你逐渐意识到你以前的工程专业知识与你的工作越来越不相关。相反，你的效率比以往任何时候都更依赖于你的一般技术直觉和激励工程师向好的方向发展的能力。</p>
</blockquote>
<blockquote>
<p>“the three Always of leadership”: Always Be Deciding, Always Be Leaving, Always Be Scaling.
&ldquo;领导力的三个总是&rdquo;：总是在做决定，总是在离开，总是在扩展。</p>
</blockquote>
<blockquote>
<p>It’s easy for imposter syndrome to kick in at this point. One technique for fighting the feeling that you don’t know what you’re doing is to simply pretend that some expert out there knows exactly what to do, and that they’re simply on vacation and you’re temporarily subbing in for them. It’s a great way to remove the personal stakes and give yourself permission to fail and learn.
在这一点上，冒名顶替综合症很容易发作。与你不知道自己在做什么的感觉作斗争的一个技巧是，简单地假装外面的某个专家完全知道该怎么做，而他们只是在度假，你只是暂时代替他们而已。这是一个消除个人利害关系的好方法，允许自己失败和学习。</p>
</blockquote>
<blockquote>
<p>You’ve been given a new problem, but (usually) not more people. Somehow you need to solve both problems now, which likely means that the original problem still needs to be managed with half as many people in half the time. You need the other half of your people to tackle the new work! We refer to this final step as the compression stage: you’re taking everything you’ve been doing and compressing it down to half the size.
你得到了一个新的问题，但（通常）没有更多的人。你现在需要同时解决这两个问题，这可能意味着原来的问题仍然需要用一半的人在一半的时间内解决。你需要另一半的人去处理新的工作！这就是你的工作。我们把这最后一步称为压缩阶段：<strong>你要把你一直在做的事情，压缩到一半的规模。</strong></p>
</blockquote>
<blockquote>
<p>I have two kinds of problems, the urgent and the important. The urgent are not impor‐ tant, and the important are never urgent.
我有两种问题，紧急的和重要的。紧急的问题并不重要，而重要的问题却从不紧急。</p>
</blockquote>
<blockquote>
<p>Instead, mindfully identify the balls that strictly fall in the top 20%—critical things that only you can do—and focus strictly on them. Give yourself explicit permission to drop the other 80%.
相反，要有意识地识别那些严格意义上属于前20%的球&ndash;只有你能做的关键事情&ndash;并严格专注于它们。给自己明确的许可，让自己放弃其他80%的事情。</p>
</blockquote>
<blockquote>
<p>If something in that middle bucket is truly critical, it ends up coming back to you anyway, eventually migrating up into the top 20%.
如果中间的桶里的东西真的很重要，它最终还是会回到你身边，最终迁移到前20%。</p>
</blockquote>
<h2 id="7-衡量生产力">7. 衡量生产力</h2>
<blockquote>
<p>At Google, we use the Goals/Signals/Metrics (GSM) framework to guide metrics creation.
在谷歌，我们使用目标/信号/指标（GSM）框架来指导指标创建。</p>
</blockquote>
<p>生产力五个核心（QUANTS）：</p>
<ul>
<li>代码的质量</li>
<li>工程师的专注</li>
<li>心智复杂性</li>
<li>节奏和速度</li>
<li>满意度</li>
</ul>
<h1 id="iii-流程">III. 流程</h1>
<h2 id="8-代码风格">8. 代码风格</h2>
<p>总体原则：</p>
<ul>
<li>规则必须发挥其作用</li>
<li>针对代码读者优化</li>
<li>要有一致性</li>
<li>避免容易出错和令人惊讶的构造</li>
<li>必要时向实际情况让步</li>
</ul>
<blockquote>
<p>We’d rather the code be tedious to type than difficult to read.
我们宁愿代码输入繁琐，而不是难以阅读。</p>
</blockquote>
<blockquote>
<p>It’s the consistency of having one answer rather than the answer itself that is the valuable part here.
有价值的是拥有一个答案的一致性，而不是答案本身。</p>
</blockquote>
<p>所有风格指南的规则都属于这三类：</p>
<ul>
<li>避免危险的规则</li>
<li>执行最佳做法的规则</li>
<li>确保一致性的规则</li>
</ul>
<blockquote>
<p>In fact, the C++ style arbiter group currently consists of four members.
事实上，C++风格的仲裁员小组目前由四个成员组成。</p>
</blockquote>
<blockquote>
<p>We use tools like clang-tidy (for C++) and Error Prone (for Java) to automate the process of enforcing rules.
For our code, we use clang-format for C++; an in-house wrapper around yapf for Python; gofmt for Go; dartfmt for Dart; and buildifier for our BUILD files.</p>
</blockquote>
<blockquote>
<p>At first, Go users complained about the enforced standard; now, users often cite gofmt as one of the many reasons they like Go.
起初，Go的用户抱怨这个强制标准；现在，用户经常把gofmt作为他们喜欢Go的众多原因之一。</p>
</blockquote>
<h2 id="9-代码审查">9. 代码审查</h2>
<blockquote>
<p>At Google, we use a custom code review tool, Critique, to support our process.
在谷歌，我们使用一个定制的代码审查工具Critique来支持我们的流程。</p>
</blockquote>
<p>在谷歌，一个典型的代码审查要经过以下步骤：</p>
<ul>
<li>用户创建一个变更，并上传到代码审查工具。</li>
<li>作者可以应用自动审查意见或进行自我审查。满意后发给一个或多个评审员。</li>
<li>评审员在代码评审工具中发表评论。有些评论要求明确的解决。有些仅仅是信息性的。</li>
<li>作者和评审员重复修改和反馈若干次。</li>
<li>在评审员对状态满意后，同意该修改，并将其标记为 LGTM。默认情况下，只需要一个LGTM，尽管惯例可能要求所有的评审员都同意该修改。</li>
<li>当一个变更被标记为LGTM后，作者可以将该变更提交到代码库中，前提是他们解决了所有的评论，并且该变更被批准。</li>
</ul>
<blockquote>
<p>Writing entirely new code is so frowned upon that some of us have a saying: “If you’re writing it from scratch, you’re doing it wrong!”
编写全新的代码是非常不受欢迎的，以至于我们中的一些人有一个说法。&ldquo;如果你从头开始写，你就做错了！&rdquo;</p>
</blockquote>
<p>审查有三个方面需要 &ldquo;批准&rdquo;：</p>
<ul>
<li>另一位工程师对代码的正确性和理解力进行检查，确认代码是合适的，并且做了作者所声称的事情。</li>
<li>来自代码所有者之一的批准，证明该代码适合于代码库的这个特定部分。</li>
<li>由拥有语言 “可读性” 认证的人批准，代码符合语言的风格和最佳实践，检查代码是否以我们期望的方式编写。</li>
</ul>
<p>大多数审查都是由一个人承担这三个角色，这就大大加快了审查过程。重要的是，作者也可以承担后两个角色，只需要另一个工程师的LGTM就可以将代码签入到他们自己的代码库中，前提是他们已经具备了该语言的“可读性”。</p>
<blockquote>
<p>The primary reviewer can focus on code correctness and the general validity of the code change; the code owner can focus on whether this change is appropriate for their part of the codebase without having to focus on the details of each line of code. An approver is often looking for something different than a peer reviewer, in other words. After all, someone is trying to check in code to their project/directory. They are more concerned with questions such as: “Will this code be easy or difficult to maintain?” “Does it add to my technical debt?” “Do we have the expertise to maintain it within our team?”
主要审查者可以关注代码的正确性和代码修改的总体有效性；代码所有者可以关注这个修改是否适合他们的那部分代码库，而不必关注每一行代码的细节。换句话说，审批者所寻找的东西往往与同行评审者不同。毕竟，有人是想把代码签入他们的项目/目录。他们更关心的是诸如以下问题。&ldquo;这段代码是容易还是难以维护？&rdquo; &ldquo;它是否增加了我的技术债务？&rdquo; &ldquo;我们的团队中是否有维护它的专业知识？&rdquo;</p>
</blockquote>
<blockquote>
<p>Specially named OWNERS files list usernames of people who have ownership respon‐ sibilities for a directory and its children.
特别命名的OWNERS文件列出了对一个目录及其子目录有所有权责任的人的用户名。</p>
</blockquote>
<p>代码审查的好处。</p>
<blockquote>
<p>Code review processes that are heavy‐weight, or that don’t scale properly, become unsustainable.
沉重的代码审查过程，或者不能适当地扩展，都是不可持续的。</p>
</blockquote>
<blockquote>
<p>To prevent the evaluation of correctness from becoming more subjective than objective, authors are generally given deference to their particular approach, whether it be in the design or the function of the introduced change. A reviewer shouldn’t propose alternatives because of personal opinion. Reviewers can propose alternatives, but only if they improve comprehension (by being less complex, for example) or functionality (by being more efficient, for example). In general, engineers are encouraged to approve changes that improve the codebase rather than wait for consensus on a more “perfect” solution. This focus tends to speed up code reviews.
为了防止对正确性的评价变得更加主观而不是客观，一般都会尊重作者的特定方法，无论是在设计上还是在引入的功能上的改变。评审员不应该因为个人意见而提出替代方案。评审员可以提出替代方案，但前提是这些替代方案能够改善理解性（例如，通过减少复杂性）或功能性（例如，通过更有效）。一般来说，我们鼓励工程师批准那些能够改善代码库的修改，而不是等待对一个更 &ldquo;完美 &ldquo;的解决方案达成共识。这种关注倾向于加快代码审查的速度。</p>
</blockquote>
<blockquote>
<p>A code review is often the first test of whether a given change is understandable to a broader audience. This perspective is vitally important because code will be read many more times than it is written, and understanding and comprehension are critically important.
代码审查通常是对一个特定的变化是否能被更多人理解的第一个测试。这个观点是非常重要的，因为代码被阅读的次数要比它被写的次数多得多，而理解和领悟是非常重要的。</p>
</blockquote>
<blockquote>
<p>Even the most capable engineers can suffer from imposter syndrome and be too self-critical. A process like code review acts as validation and recognition for one’s work.
即使是最有能力的工程师也会患上冒名顶替综合症，并且过于自我批判。像代码审查这样的过程是对一个人的工作的验证和认可。</p>
</blockquote>
<blockquote>
<p>Reviewers can even mark some comments “FYI,” requiring no action; they are simply added as an aid to the author.
审稿人甚至可以将一些评论标记为 &ldquo;仅供参考&rdquo;，不需要采取任何行动；它们只是作为作者的一种帮助而添加。</p>
</blockquote>
<blockquote>
<p>If an author can demonstrate that several approaches are equally valid, the reviewer should accept the preference of the author.
如果作者能证明几种方法都同样有效，评审员应接受作者的偏好。</p>
</blockquote>
<blockquote>
<p>At Google, we expect feedback from a code review within 24 (working) hour. … Few things annoy an author more than getting feedback from a review, addressing it, and then continuing to get unrelated further feedback in the review process.
在谷歌，我们希望在24（工作）小时内得到代码审查的反馈。&hellip;&hellip;很少有事情比从审查中得到反馈，解决它，然后继续在审查过程中得到无关的进一步反馈更让作者恼火。</p>
</blockquote>
<blockquote>
<p>Remember that you are not your code, and that this change you propose is not “yours” but the team’s. After you check that piece of code into the codebase, it is no longer yours in any case.
记住，你不是你的代码，你提出的这个修改不是 &ldquo;你的&rdquo;，而是团队的。在你将这段代码检入代码库之后，它无论如何都不再是你的了。</p>
</blockquote>
<blockquote>
<p>It’s important to treat each reviewer comment within a code review as a TODO item; a particular comment might not need to be accepted without question, but it should at least be addressed. &hellip; One common way to keep such debates civil if an author doesn’t agree with a reviewer is to offer an alternative and ask the reviewer to PTAL (please take another look).
重要的是要把代码审查中的每个审查者的评论当作一个TODO项目；一个特定的评论可能不需要被无条件接受，但它至少应该被解决。&hellip; 如果作者不同意评审员的意见，保持这种辩论的一个常见方法是提供一个替代方案，并要求评审员PTAL（请再看看）。</p>
</blockquote>
<blockquote>
<p>Google’s code review process discour‐ ages massive changes consisting of fully formed projects, and reviewers can rightfully reject such changes as being too large for a single review.
谷歌的代码审查程序不鼓励由完全成型的项目组成的大规模修改，审查员可以正确地拒绝这种修改，因为它对一次审查来说太大。</p>
</blockquote>
<blockquote>
<p>“Small” changes should generally be limited to about 200 lines of code. &hellip; Most changes at Google are expected to be reviewed within about a day. (This doesn’t necessarily mean that the review is over within a day, but that initial feedback is provided within a day.) About 35% of the changes at Google are to a single file.
一般来说，&ldquo;小 &ldquo;改动应该限制在200行左右的代码。&hellip; 在谷歌，大多数的修改预计会在一天之内得到审查。(这并不一定意味着审查会在一天内结束，但初步反馈会在一天内提供）。在谷歌，大约有35%的修改是针对单一文件的。</p>
</blockquote>
<blockquote>
<p>Because code reviews are typically small, it’s common for almost all code reviews at Google to be reviewed by one and only one person. &hellip; It’s not uncommon for multiple people to comment on any given change — most code reviews are sent to a team member, but also CC’d to appropriate teams — but the primary reviewer is still the one whose LGTM is desired, and only one LGTM is necessary for any given change. Any other comments, though important, are still optional.
因为代码审查通常是小规模的，所以在谷歌，几乎所有的代码审查都是由一个人审查的，而且只有一个人。多人对任何给定的修改发表评论的情况并不少见&ndash;大多数代码审查都是发给一个团队成员，但也会抄送给适当的团队&ndash;但主要的审查者仍然是希望得到LGTM的人，而且对于任何给定的修改，只有一个LGTM是必要的。任何其他评论，尽管很重要，但仍然是可选的。</p>
</blockquote>
<h2 id="10-文档">10. 文档</h2>
<blockquote>
<p>Overall, the state of engineering documentation in the late 2010s is similar to the state of software testing in the late 1980s.
总的来说，2010年代末的工程文档状况与1980年代末的软件测试状况相似。</p>
</blockquote>
<p><a href="https://www.writethedocs.org/guide/docs-as-code">Docs as Code</a>.</p>
<blockquote>
<p>The people who could fix the documents were not the people who used them. &hellip; Conversely, the people best able to fix the documents often didn’t need to consult them after they were written.
能够修复文档的人并不是使用它们的人。&hellip; 反过来说，最能修复文件的人在文档写好后往往不需要查阅它们。</p>
</blockquote>
<p>了解文档的受众。</p>
<blockquote>
<p>By keeping a document short and clear, you will ensure that it will satisfy both an expert and a novice.
通过保持文件的简短和清晰，你将确保它能让专家和新手都满意。</p>
</blockquote>
<p>文档的类型。（API 参考，实现细节，设计文档，教学等。）</p>
<blockquote>
<p>In this author’s opinion, the quality of documentation at Google is better than in most software engineering shops.
在笔者看来，谷歌的文档质量要比大多数软件工程公司的好。</p>
</blockquote>
<h2 id="11-测试概览">11. 测试（概览）</h2>
<blockquote>
<p>The changes in GWS marked a watershed for testing culture at Google as teams in other parts of the company saw the benefits of testing and moved to adopt similar tactics.
GWS的变化标志着谷歌测试文化的一个分水岭，因为公司其他部门的团队看到了测试的好处，并开始采用类似的策略。</p>
</blockquote>
<blockquote>
<p>Software documentation is notoriously unreliable.
软件文档是出了名的不可靠。</p>
</blockquote>
<blockquote>
<p>In brief, small tests run in a single process, medium tests run on a single machine, and large tests run wherever they want.
简而言之，小型测试在一个进程中运行，中型测试在一台机器上运行，而大型测试则在任何地方运行。</p>
</blockquote>
<p>Flaky test are expensive.</p>
<blockquote>
<p>Our experience suggests that as you approach 1% flakiness, the tests begin to lose value. At Google, our flaky rate hovers around 0.15%, which implies thousands of flakes every day.
我们的经验表明，当你接近1%的 flakiness 时，测试开始失去价值。在谷歌，我们的 flakiness 徘徊在0.15%左右，这意味着每天有成千上万的 flakes。</p>
</blockquote>
<blockquote>
<p>As a very rough guideline, we tend to aim to have a mix of around 80% of our tests being narrow-scoped unit tests that validate the majority of our business logic; 15% medium-scoped integration tests that validate the interactions between two or more components; and 5% end-to-end tests that validate the entire system.
作为一个非常粗略的指导方针，我们倾向于将80%左右的测试混合为狭义的单元测试，以验证大部分的业务逻辑；15%的中等范围的集成测试，以验证两个或多个组件之间的相互作用；以及5%的端到端测试，以验证整个系统。</p>
</blockquote>
<blockquote>
<p>The Beyoncé Rule: “If you liked it, then you shoulda put a test on it.”
碧昂斯规则：如果你喜欢它，那么你应该对它进行测试。</p>
</blockquote>
<blockquote>
<p>Code coverage can provide some insight into untested code, but it is not a substitute for thinking critically about how well your system is tested.
代码覆盖率可以提供一些对未测试代码的洞察力，但它不能替代对系统测试情况的批判性思考。</p>
</blockquote>
<blockquote>
<p>Some of the worst offenders of brittle tests come from the misuse of mock objects. Google’s codebase has suffered so badly from an abuse of mocking frameworks that it has led some engineers to declare “no more mocks!”
脆性测试的一些最严重的犯罪者来自于对模拟对象的误用。谷歌的代码库因滥用模拟框架而受到严重影响，导致一些工程师宣布 &ldquo;不再使用模拟对象&rdquo;。</p>
</blockquote>
<blockquote>
<p>Each supported language at Google has one standard test framework and one standard mocking/stubbing library.
谷歌支持的每种语言都有一个标准的测试框架和一个标准的  mocking/stubbing 库。</p>
</blockquote>
<p>推广测试文化：</p>
<ul>
<li>Orientation.</li>
<li>测试认证计划。</li>
<li>Testing on the Toilet. （厕所小广告。）</li>
</ul>
<p><a href="https://testing.googleblog.com">Google Testing Blog.</a></p>
<h2 id="12-单元测试">12. 单元测试</h2>
<blockquote>
<p>Due to their many advantages, most tests written at Google are unit tests, and as a rule of thumb, we encourage engineers to aim for a mix of about 80% unit tests and 20% broader-scoped tests.
由于它们有很多优点，在Google写的大多数测试都是单元测试，作为一个经验法则，我们鼓励工程师把目标放在80%的单元测试和20%的范围更广的测试。</p>
</blockquote>
<blockquote>
<p>Bad tests must be fixed before they are checked in, lest they impose a drag on future engineers.
不好的测试必须在签入前得到修复，以免它们给未来的工程师带来拖累。</p>
</blockquote>
<p>Preventing brittle tests:</p>
<ul>
<li>Strive for unchanging tests. 不需要随着系统改变。</li>
<li>Test via public APIs, rather than its implementation details.
<ul>
<li>This is sometimes called the &ldquo;Use the front door first principle.”</li>
</ul>
</li>
<li>Test state, not Interactions.</li>
<li>Writing clear tests. Make your tests complete and concise.</li>
<li>Test behaviors, not methods.</li>
<li>&hellip;</li>
</ul>
<blockquote>
<p>A good trick if you’re stuck is to try starting the test name with the word “should.”</p>
</blockquote>
<blockquote>
<p>nstead of being completely DRY, test code should often strive to be DAMP—that is, to promote “Descriptive And Meaningful Phrases.”
测试代码应该努力做到DAMP &ndash; 即 &ldquo;描述性和有意义的短语&rdquo;。</p>
</blockquote>
<h2 id="13-测试替身test-doubles">13. 测试替身（Test Doubles）</h2>
<blockquote>
<p>A test double is an object or function that can stand in for a real implementation in a test, similar to how a stunt double can stand in for an actor in a movie.
测试替身是一个对象或函数，可以在测试中代替真正的实现，类似于特技替身可以代替电影中的演员。</p>
</blockquote>
<blockquote>
<p>One lesson we learned the hard way is the danger of overusing mocking frameworks, which allow you to easily create test doubles.
我们学到的一个教训是过度使用 mocking 框架的危险性，它允许你轻松地创建测试替身。</p>
</blockquote>
<blockquote>
<p>Dependency injection is a common technique for introducing seams.
依赖性注入是引入接缝的一种常见技术。</p>
</blockquote>
<blockquote>
<p>Mocking frameworks exist for most major programming languages. At Google, we use Mockito for Java, the googlemock component of Googletest for C++, and unittest.mock for Python.
大多数主要的编程语言都有 mocking 框架。在谷歌，我们使用Java的Mockito，C++的Googletest的googlemock组件，以及Python的unitest.mock。</p>
</blockquote>
<blockquote>
<p>If using a real implementation is not feasible within a test, the best option is often to use a fake in its place. A fake is preferred over other test double techniques because it behaves similarly to the real implementation: the system under test shouldn’t even be able to tell whether it is interacting with a real implementation or a fake.
如果在测试中使用一个真实的实现是不可行的，最好的选择往往是使用一个假的来代替它。假的比其他测试的替身技术更受欢迎，因为它的行为与真实的实现相似：被测试的系统甚至不应该能够知道它是在与真实的实现还是假的互动。</p>
</blockquote>
<blockquote>
<p>The team that owns the real implementation should write and maintain a fake.
拥有真实实现的团队应该编写和维护一个假的。</p>
</blockquote>
<blockquote>
<p>Some people at Google jokingly refer to tests that overuse interaction testing as change-detector tests because they fail in response to any change to the pro‐ duction code, even if the behavior of the system under test remains unchanged.
谷歌的一些人开玩笑地把过度使用交互测试的测试称为变化检测器测试，因为它们对程序代码的任何变化都会失效，即使被测系统的行为没有变化。</p>
</blockquote>
<h2 id="14-更大规模测试">14. 更大规模测试</h2>
<blockquote>
<p>Almost all unit tests at Google are written by the same engineer who is writing the unit under test.
在谷歌，几乎所有的单元测试都是由编写被测单元的同一个工程师编写的。</p>
</blockquote>
<blockquote>
<p>One common approach we use for manual exploratory testing is the bug bash. A team of engineers and related personnel (managers, product managers, test engineers, anyone with familiarity with the product) schedules a “meeting,” but at this session, everyone involved manually tests the product.
我们在手动探索性测试中使用的一种常见方法是bug bash。一个由工程师和相关人员（经理、产品经理、测试工程师、任何熟悉产品的人）组成的团队安排一个 &ldquo;会议&rdquo;，但在这个会议上，每个人都对产品进行手动测试。</p>
</blockquote>
<blockquote>
<p>For years, Google has run an annual war game called DiRT (Disaster Recovery Testing) during which faults are injected into our infrastructure at a nearly planetary scale. We simulate everything from datacenter fires to malicious attacks. In one mem‐ orable case, we simulated an earthquake that completely isolated our headquarters in Mountain View, California, from the rest of the company. Doing so exposed not only technical shortcomings but also revealed the challenge of running a company when all the key decision makers were unreachable.
多年来，谷歌一直在进行一场名为DiRT（灾难恢复测试）的年度战争游戏，期间将故障注入我们的基础设施，其规模几乎达到了地球级。我们模拟了从数据中心火灾到恶意攻击的一切。在一个令人难忘的案例中，我们模拟了一场地震，将我们位于加州山景城的总部与公司其他部门完全隔离。这样做不仅暴露了技术上的缺陷，而且也揭示了在所有关键决策者都无法联系的情况下，经营一家公司的挑战。</p>
</blockquote>
<blockquote>
<p>During this test, almost no one could get anything done, so many people gave up on work and went to one of our many cafes, and in doing so, we ended up creating a DDoS attack on our cafe teams!
在这次测试中，几乎没有人能够完成任何事情，所以很多人放弃了工作，去了我们众多的咖啡馆之一，在这样做的过程中，我们最终给我们的咖啡馆团队制造了一次DDoS攻击!</p>
</blockquote>
<h2 id="15-弃用deprecation">15. 弃用（Deprecation）</h2>
<blockquote>
<p>Unlike with most of the other topics we have discussed in this book, Google is still learning how best to deprecate and remove software systems.
与我们在本书中讨论的大多数其他主题不同，谷歌仍在学习如何最好地废止和删除软件系统。</p>
</blockquote>
<blockquote>
<p>Earlier we made the assertion that “code is a liability, not an asset.” If that is true, why have we spent most of this book discussing the most efficient way to build software systems that can live for decades? Why put all that effort into creating more code when it’s simply going to end up on the liability side of the balance sheet?
Code itself doesn’t bring value: it is the functionality that it provides that brings value. That functionality is an asset if it meets a user need: the code that implements this functionality is simply a means to that end. If we could get the same functionality from a single line of maintainable, understandable code as 10,000 lines of convoluted spaghetti code, we would prefer the former. Code itself carries a cost—the simpler the code is, while maintaining the same amount of functionality, the better.
Instead of focusing on how much code we can produce, or how large is our codebase, we should instead focus on how much functionality it can deliver per unit of code and try to maximize that metric. One of the easiest ways to do so isn’t writing more code and hoping to get more functionality; it’s removing excess code and systems that are no longer needed. Deprecation policies and procedures make this possible.
前面我们曾断言，&ldquo;代码是一种负债，而不是一种资产&rdquo;。如果这是真的，为什么我们花了本书的大部分篇幅来讨论建立可以活几十年的软件系统的最有效方法？为什么要把所有的精力都放在创造更多的代码上，而这些代码最终会成为资产负债表上的负债？
代码本身并不带来价值：它所提供的功能才带来价值。如果这个功能能满足用户的需求，它就是一种资产：实现这个功能的代码只是达到这个目的的一种手段。如果我们能从一行可维护的、可理解的代码中获得与一万行错综复杂的意大利面条代码相同的功能，我们会选择前者。代码本身是有成本的，在保持相同功能的情况下，代码越简单越好。
与其关注我们能产生多少代码，或者我们的代码库有多大，不如关注每单位的代码能提供多少功能，并努力使这个指标最大化。要做到这一点，最简单的方法之一不是编写更多的代码并希望获得更多的功能；而是删除多余的代码和不再需要的系统。去除政策和程序使这成为可能。</p>
</blockquote>
<blockquote>
<p>Another surprising reluctance to deprecate is emotional attachment to old systems, particularly those that the deprecator had a hand in helping to create.
另一个令人惊讶的不愿意废弃的原因是对旧系统的情感依恋，特别是那些废弃者曾帮助创建的系统。</p>
</blockquote>
<blockquote>
<p>There’s an old joke within Google that there are two ways of doing things: the one that’s deprecated, and the one that’s not-yet-ready.
在谷歌内部有一个老笑话，有两种做事的方式：一种是被废弃的方式，另一种是尚未准备好的方式。</p>
</blockquote>
<blockquote>
<p>And in spite of the popular notion of software engineers as data-driven automata, it can be psychologically difficult to plan for the eventual demise of the creations we are working so hard to build.
尽管有软件工程师是数据驱动的自动机的流行概念，但从心理上来说，要为我们辛辛苦苦打造的作品的最终消亡做打算是很困难的。</p>
</blockquote>
<blockquote>
<p>This does not imply that the schedule can’t change, but empower the team running the deprecation process to break noncompliant users after they have been sufficiently warned through efforts to migrate them.
这并不意味着时间表不能改变，而是授权运行废止程序的团队，在通过努力迁移不符合要求的用户并对其进行充分警告后，打破这些用户。</p>
</blockquote>
<blockquote>
<p>Frequently at Google, when a system is slated for deprecation and removal, the team will announce planned outages of increasing duration in the months and weeks prior to the turndown.
在谷歌，当一个系统被计划废除和移除时，团队会在关闭前的几个月和几周内宣布有计划的中断，并且持续时间越来越长。</p>
</blockquote>
<blockquote>
<p>Without backsliding prevention, deprecation can become a game of whack-a-mole.
如果没有防止倒退的措施，弃用就会成为一个打地鼠的游戏。</p>
</blockquote>
<h1 id="iv-工具">IV. 工具</h1>
<h2 id="16-版本和分支管理">16. 版本和分支管理</h2>
<blockquote>
<p>Unfortunately, those attempts to move toward more common tools like Git have been stymied by the sheer size of the codebase and userbase, to say nothing of Hyrum’s Law effects tying us to a particular VCS and interface for that VCS. This is perhaps not surprising: most existing tools don’t scale well with 50,000 engineers and tens of millions of commits.
不幸的是，由于代码库和用户群的规模太大，再加上海勒姆法则的影响，我们被束缚在一个特定的VCS和该VCS的界面上，这些试图向Git这样的通用工具发展的尝试受到了阻碍。这也许并不令人惊讶：大多数现有的工具在面对5万名工程师和数千万的提交时都不能很好地扩展。</p>
</blockquote>
<blockquote>
<p>There’s an (oft-unspoken) truth when discussing version control: the technology is only one part of it for any given organization; there is almost always an equal amount of policy and usage convention on top of that.
在讨论版本控制时，有一个（经常不说的）事实：对于任何特定的组织来说，技术只是其中的一部分；几乎总是有同等数量的政策和使用惯例在上面。</p>
</blockquote>
<blockquote>
<p>We believe that a version control policy that makes extensive use of dev branches as a means toward product stability is inherently misguided.
我们认为，将大量使用开发分支作为实现产品稳定性的手段的版本控制政策本身就是一种误导。</p>
</blockquote>
<blockquote>
<p>Some unlucky engineer becomes the Build Master/Merge Coordinator/Content Management Engineer, focused on acting as the single point coordinator to merge all the disparate branches in the organization.
一些不走运的工程师成了Build Master/Merge Coordinator/Content Management Engineer，专注于充当单点协调人，合并组织中所有不同的分支。</p>
</blockquote>
<blockquote>
<p>We rely on an in-house-developed centralized VCS called Piper.
我们依靠一个内部开发的集中式VCS，称为Piper。</p>
</blockquote>
<blockquote>
<p>In addition to our VCS, one key feature of Google’s version control policy is what we’ve come to refer to as “One Version.” This extends the “Single Source of Truth” concept we looked at earlier—ensuring that a developer knows which branch and repository is their source of truth—to something like “For every dependency in our repository, there must be only one version of that dependency to choose.”
除了我们的VCS之外，谷歌版本控制政策的一个关键特征就是我们所说的 &ldquo;一个版本&rdquo;。这扩展了我们前面提到的 &ldquo;单一真理来源 &ldquo;的概念&ndash;确保开发者知道哪个分支和版本库是他们的真理来源&ndash;到类似于 &ldquo;对于我们版本库中的每个依赖，必须只有一个版本的依赖可以选择。&rdquo;</p>
</blockquote>
<blockquote>
<p>Across the roughly 1,000 teams that work in the Google monorepo, there are only a couple that have such a dev branch.
在Google monorepo中工作的大约1000个团队中，只有几个有这样的开发分支。</p>
</blockquote>
<blockquote>
<p>Given all of that and our belief in the merits of the One-Version Rule, it is reasonable to ask whether a monorepo is the One True Way. By comparison, the open source community seems to work just fine with a “manyrepo” approach built on a seemingly infinite number of noncoordinating and nonsynchronized project repositories. In short: no, we don’t think the monorepo approach as we’ve described it is the perfect answer for everyone.
考虑到所有这些，以及我们对 &ldquo;单一版本规则 &ldquo;优点的信念，我们有理由问，monorepo 是否是唯一正确的方法。相比之下，开源社区似乎可以用 &ldquo;manyrepo&rdquo; 的方法来工作，而这种方法建立在看似无限多的非协调和非同步的项目库上。简而言之：不，我们不认为我们所描述的 monorepo 方法是对每个人都是完美的答案。</p>
</blockquote>
<blockquote>
<p>A very similar set of issues governs whether to prefer a monorepo or a collection of finer-grained repositories. The specific decisions of how to store your source code (or store your files, for that matter) are easily debatable, and in some cases, the particulars of your organization and your workflow are going to matter more than others. These are decisions you’ll need to make yourself.
What is important is not whether we focus on monorepo; it’s to adhere to the One-Version principle to the greatest extent possible: developers must not have a choice when adding a dependency onto some library that is already in use in the organization.
一组非常相似的问题决定了是选择 monorepo 还是更细粒度的库的集合。如何存储你的源代码（或存储你的文件）的具体决定是很容易争论的，在某些情况下，你的组织和你的工作流程的特殊性会比其他的更重要。这些都是你需要自己做出的决定。
重要的不是我们是否关注 monorepo；而是最大限度地坚持一个版本原则：开发人员在向组织中已经使用的某个库添加依赖关系时不能有选择。</p>
</blockquote>
<blockquote>
<p>Git submodules, Bazel with external dependencies, and CMake subprojects all allow modern developers to syn‐ thesize something weakly approximating monorepo behavior without the costs and downsides of a monorepo.
Git子模块、具有外部依赖的Bazel和CMake子项目都允许现代的开发者在没有单项目的成本和缺点的情况下，将一些弱的近似单项目的行为协同起来。</p>
</blockquote>
<blockquote>
<p>Fine-grained repositories in a federated/virtual-monorepo (VMR)–style repository can make it easier to isolate experimental or top-secret projects while still holding to One Version and allowing access to common utilities.
Federated/virtual-monorepo (VMR) 式的细粒度仓库可以更容易地隔离实验性或绝密性项目，同时仍然坚持一个版本，并允许访问通用工具。</p>
</blockquote>
<blockquote>
<p>To put it another way: if every project in your organization has the same secrecy, legal, privacy, and security requirements, a true monorepo is a fine way to go. Otherwise, aim for the functionality of a monorepo, but allow yourself the flexibility of implementing that experience in a different fashion. If you can manage with disjoint repositories and adhere to One Version or your workload is all disconnected enough to allow truly separate repositories, great. Otherwise, synthesizing something like a VMR in some fashion may represent the best of both worlds.
After all, your choice of filesystem format really doesn’t matter as much as what you write to it.
换句话说：如果你的组织中的每个项目都有相同的保密、法律、隐私和安全要求，那么真正的monorepo是一种很好的方式。否则，就以monorepo的功能为目标，但允许自己以不同的方式灵活地实现这些经验。如果你可以用不相干的存储库来管理，并且坚持一个版本，或者你的工作负载都是不相干的，足以允许真正的独立存储库，那就太好了。否则，以某种方式合成类似VMR的东西可能代表了两个世界的最佳状态。
毕竟，你对文件系统格式的选择并不像你对它的写法那么重要。</p>
</blockquote>
<blockquote>
<p>Google isn’t the only organization to publicly discuss the benefits of a monorepo approach. Microsoft, Facebook, Netflix, and Uber have also publicly mentioned their reliance on the approach. DORA has published about it extensively. It’s vaguely possible that all of these successful, long-lived companies are misguided, or at least that their situations are sufficiently different as to be inapplicable to the average smaller organization. Although it’s possible, we think it is unlikely.
谷歌并不是唯一一个公开讨论monorepo方法的好处的组织。微软、Facebook、Netflix和Uber也公开提到他们对这种方法的依赖。DORA已经广泛地发表了这方面的内容。依稀有可能的是，所有这些成功的、长寿的公司都被误导了，或者至少他们的情况有足够的不同，以至于不适用于一般的小型组织。虽然有这种可能，但我们认为这种可能性不大。</p>
</blockquote>
<blockquote>
<p>The other major argument against monorepos is that it doesn’t match how develop‐ ment happens in the Open Source Software (OSS) world. Although true, many of the practices in the OSS world come (rightly) from prioritizing freedom, lack of coordi‐ nation, and lack of computing resources. Separate projects in the OSS world are effec‐ tively separate organizations that happen to be able to see one another’s code. Within the boundaries of an organization, we can make more assumptions: we can assume the availability of compute resources, we can assume coordination, and we can assume that there is some amount of centralized authority.
反对monorepo的另一个主要论点是，它不符合开源软件（OSS）世界中的开发方式。虽然这是事实，但开放源码软件世界中的许多做法（正确地）来自于对自由的优先考虑，缺乏合作，以及缺乏计算资源。在开放源码软件世界中，独立的项目实际上是独立的组织，碰巧可以看到彼此的代码。在一个组织的边界内，我们可以做更多的假设：我们可以假设计算资源的可用性，我们可以假设协调，我们可以假设有一定程度的集中式权威。</p>
</blockquote>
<blockquote>
<p>A less common but perhaps more legitimate concern with the monorepo approach is that as your organization scales up, it is less and less likely that every piece of code is subject to exactly the same legal, compliance, regulatory, secrecy, and privacy requirements. One native advantage of a manyrepo approach is that separate repositories are obviously capable of having different sets of authorized developers, visibility, permis‐ sions, and so on. Stitching that feature into a monorepo can be done but implies some ongoing carrying costs in terms of customization and maintenance.
对于 monorepo 的方法，一个不太常见但可能更合理的担忧是，随着你的组织规模的扩大，越来越不可能每一段代码都受到完全相同的法律、合规、监管、保密和隐私要求的约束。manyrepo 方法的一个原生优势是，独立的库显然能够拥有不同的授权开发者、可见性、许可等等。将该功能拼接到一个 monorepo 中是可以做到的，但这意味着在定制和维护方面的一些持续成本。</p>
</blockquote>
<blockquote>
<p>At the same time, the industry seems to be inventing lightweight interrepository linkage over and over again. Sometimes, this is in the VCS (Git submodules) or the build system. So long as a collection of repositories have a consistent understanding of “what is trunk,” “which change happened first,” and mechanisms to describe depen‐ dencies, we can easily imagine stitching together a disparate collection of physical repositories into one larger VMR. Even though Piper has done very well for us, investing in a highly scaling VMR and tools to manage it and relying on off-the-shelf customization for per-repository policy requirements could have been a better investment.
与此同时，业界似乎在一次又一次地发明轻量级的库间链接。有时，这是在VCS（Git子模块）或构建系统中。只要存储库的集合对 &ldquo;什么是主干&rdquo;、&ldquo;哪个变化先发生 &ldquo;有一致的理解，并有描述依赖性的机制，我们就可以很容易地想象把不同的物理存储库的集合缝合到一个更大的VMR中。尽管Piper为我们做得很好，但投资于一个高度扩展的VMR和工具来管理它，并依靠现成的定制来满足每个库的策略要求，可能是一个更好的投资。</p>
</blockquote>
<p><a href="https://github.com/joelparkerhenderson/monorepo-vs-polyrepo">monorepo-vs-polyrepo</a></p>
<h2 id="17-代码搜索">17. 代码搜索</h2>
<blockquote>
<p>GSearch originally ran on Jeff Dean’s personal computer, which once caused company-wide distress when he went on vacation and it was shut down!
GSearch最初是在Jeff Dean的个人电脑上运行的，当他去度假时，它曾经引起了全公司的困扰，电脑被关闭了!</p>
</blockquote>
<blockquote>
<p>About 16% of Code Searches try to answer the question of where a specific piece of information exists in the codebase.
大约16%的代码搜索试图回答代码库中某一特定信息的存在位置问题。</p>
</blockquote>
<blockquote>
<p>Roughly one quarter of Code Searches are classic file browsing, to answer the question of what a specific part of the codebase is doing.
大约四分之一的代码搜索是传统的文件浏览，以回答代码库的特定部分在做什么的问题。</p>
</blockquote>
<blockquote>
<p>The most frequent use case—about one third of Code Searches—are about seeing examples of how others have done something.
最常见的使用情况&ndash;大约三分之一的代码搜索&ndash;是关于看到别人是如何做某事的例子。</p>
</blockquote>
<blockquote>
<p>About 16% of Code Searches try to answer the question of why a certain piece of code was added, or why it behaves in a certain way.
大约16%的代码搜索试图回答为什么要添加某段代码，或者为什么它的行为方式是某种方式。</p>
</blockquote>
<blockquote>
<p>About 8% of Code Searches try to answer questions around who or when someone introduced a certain piece of code.
大约8%的代码搜索试图回答围绕谁或何时有人引入某段代码的问题。</p>
</blockquote>
<blockquote>
<p>Over the years, our index changed from the original trigram-based solu‐ tion, through a custom suffix array–based solution, to the current sparse n-gram solution.
多年来，我们的索引从最初的基于Trigram的解决方案，到基于自定义后缀数组的解决方案，再到现在的稀疏n-gram解决方案。</p>
</blockquote>
<p>At Google, the key tool for this is Code Search.</p>
<p><a href="https://kythe.io/">Kythe</a></p>
<h2 id="18-构建系统">18. 构建系统</h2>
<blockquote>
<p>If you ask Google engineers what they like most about working at Google (besides the free food and cool products), you might hear something surprising: engineers love the build system.
如果你问谷歌的工程师，他们最喜欢在谷歌工作的什么（除了免费的食物和很酷的产品），你可能会听到一些令人惊讶的事情：工程师们喜欢构建系统。</p>
</blockquote>
<blockquote>
<p>Most major build systems in use today, such as Ant, Maven, Gradle, Grunt, and Rake, are task based.
目前使用的大多数主要构建系统，如Ant、Maven、Gradle、Grunt和Rake，都是基于任务的。</p>
</blockquote>
<blockquote>
<p>Google’s remote cache is called ObjFS. It consists of a backend that stores build outputs in Bigtables distributed throughout our fleet of production machines and a frontend FUSE daemon named objfsd that runs on each developer’s machine.
谷歌的远程缓存被称为ObjFS。它由一个后端和一个前端FUSE守护程序组成，前者将构建输出存储在Bigtables中，分布在我们的生产机群中，后者在每个开发人员的机器上运行，名为objfsd。</p>
</blockquote>
<blockquote>
<p>Google’s remote execution system is called Forge. A Forge client in Blaze called the Distributor sends requests for each action to a job running in our datacenters called the Scheduler.
谷歌的远程执行系统被称为Forge。Blaze中的Forge客户端称为 &ldquo;分配器&rdquo;，它将每个行动的请求发送给在我们数据中心运行的称为 &ldquo;调度器 &ldquo;的工作。</p>
</blockquote>
<blockquote>
<p>Another alternative that completely sidesteps the issue is to vendor your project’s dependencies. When a project vendors its dependencies, it checks them into source control alongside the project’s source code, either as source or as binaries. This effec‐ tively means that all of the project’s external dependencies are converted to internal dependencies. Google uses this approach internally, checking every third-party library referenced throughout Google into a third_party directory at the root of Goo‐ gle’s source tree. However, this works at Google only because Google’s source control system is custom built to handle an extremely large monorepo, so vendoring might not be an option for other organizations.
另一个完全避开这个问题的办法是将你的项目的依赖关系卖给别人。当一个项目销售它的依赖关系时，它把它们和项目的源代码一起检查到源码控制中，可以是源码，也可以是二进制文件。这有效地意味着项目的所有外部依赖被转换为内部依赖。谷歌在内部使用这种方法，将整个谷歌引用的每一个第三方库都检查到谷歌源代码树根部的第三方目录中。然而，这在谷歌是可行的，因为谷歌的源码控制系统是为处理一个极其庞大的单库而定制的，所以对于其他组织来说，Vendoring可能不是一个选择。</p>
</blockquote>
<p>Nix?</p>
<blockquote>
<p>External dependencies should be versioned explicitly under source control. Relying on “latest” versions is a recipe for disaster and unreproducible builds.
外部依赖应该在源代码控制下明确地进行版本控制。依赖于 &ldquo;最新 &ldquo;的版本是一种灾难和不可复制的构建的秘诀。</p>
</blockquote>
<h2 id="19-代码审查工具">19. 代码审查工具</h2>
<p>Critique.</p>
<blockquote>
<p>Across these guiding principles, simplicity has probably had the most impact on the tool.
在这些指导原则中，简单性可能对该工具的影响最大。</p>
</blockquote>
<blockquote>
<p>Anyone can comment on changes, providing a “drive-by review” as they see it necessary.
任何人都可以对变化发表评论，在他们认为必要时提供 &ldquo;路过审查&rdquo;。</p>
</blockquote>
<blockquote>
<p>In emergency cases, the author can forcefully commit their change and have it reviewed after commit.
在紧急情况下，作者可以强行提交他们的修改，并在提交后让人审查。</p>
</blockquote>
<p>评审员的选择工具会考虑到以下因素：</p>
<ul>
<li>谁拥有被修改的代码。</li>
<li>谁对该代码最熟悉（即，谁最近修改过该代码）。</li>
<li>谁可以进行审查（即没有离开办公室，最好是在同一时区）。</li>
</ul>
<blockquote>
<p>Critique also offers the ability to track review progress via per-person state. Reviewers have checkboxes to mark individual files at the latest snapshot as reviewed, helping the reviewer keep track of what they have already looked at. When the author modi‐ fies a file, the “reviewed” checkbox for that file is cleared for all reviewers because the latest snapshot has been updated.
Critique 还提供了通过每个人的状态来跟踪审查进度的能力。审稿人可以用复选框将最新快照中的单个文件标记为已审阅，帮助审稿人跟踪他们已经看过的内容。当作者修改一个文件时，该文件的 &ldquo;已审阅 &ldquo;复选框对所有审阅者来说都是清空的，因为最新的快照已经更新。</p>
</blockquote>
<blockquote>
<p>The attention set comprises the set of people on which a change is currently blocked. When a reviewer or author is in the attention set, they are expected to respond in a timely manner.  … After we implemented this feature, our users had a difficult time imagining the previous state. The prevailing opinion is: how did we get along without this? The alterna‐ tive before we implemented this feature was chatting between reviewers and authors to understand who was dealing with a change. This feature also emphasizes the turn-based nature of code review; it is always at least one person’s turn to take action.
关注集包括当前被 block 在某一变更上的人的集合。当评审员或作者在注意力集合中时，他们应该及时做出反应。&hellip;&hellip;在我们实施这个功能后，我们的用户很难想象以前的状态。普遍的看法是：没有这个功能，我们是怎么过的？在我们实施这个功能之前，另一个办法是在审稿人和作者之间进行聊天，以了解谁在处理一个变化。这个功能也强调了代码审查的轮流性质；总是至少有一个人要采取行动。</p>
</blockquote>
<blockquote>
<p>An LGTM stamp from a reviewer means that “I have reviewed this change, believe that it meets our standards, and I think it is okay to commit it after addressing unre‐ solved comments.” An Approval stamp from a reviewer means that “as a gatekeeper, I allow this change to be committed to the codebase.” A reviewer can mark comments as unresolved, meaning that the author will need to act upon them. When the change has at least one LGTM, sufficient approvals and no unresolved comments, the author can then commit the change. Note that every change requires an LGTM regardless of approval status, ensuring that at least two pairs of eyes viewed the change.
评审员的LGTM印章意味着 &ldquo;我已经审阅了这个修改，相信它符合我们的标准，并且我认为在解决了未解决的评论之后，可以提交它。&rdquo; 评审员的批准印章意味着 &ldquo;作为一个把关人，我允许这个修改被提交到代码库中&rdquo;。评审员可以将评论标记为未解决，这意味着作者需要对它们采取行动。当修改至少有一个LGTM，有足够的批准，没有未解决的评论，作者就可以提交修改。请注意，每项修改都需要一个LGTM，无论批准状态如何，以确保至少有两双眼睛在看这个修改。</p>
</blockquote>
<blockquote>
<p>Gerrit also supports a more sophisticated scoring system. A reviewer can veto a change by placing a –2 score, and the scoring system is highly configurable.
Gerrit还支持一个更复杂的评分系统。评审员可以通过打-2分来否决一项修改，而且评分系统是高度可配置的。</p>
</blockquote>
<blockquote>
<p>Time spent in code reviews is time not spent coding, so any optimization of the review process can be a productivity gain for the company.
花在代码审查上的时间就是没有花在编码上的时间，所以对审查过程的任何优化都可以为公司带来生产力的提高。</p>
</blockquote>
<h2 id="20-静态分析">20. 静态分析</h2>
<p>Tricorder: Google’s Static Analysis Platform.</p>
<p>Focus on developer happiness.</p>
<h2 id="21-依赖管理">21. 依赖管理</h2>
<blockquote>
<p>As the Open Source Software (OSS) model continues to grow and expand into new domains, and the dependency graph for many popular projects continues to expand over time, dependency management is perhaps becoming the most important prob‐ lem in software engineering policy. We are no longer disconnected islands built on one or two layers outside an API. Modern software is built on towering pillars of dependencies; but just because we can build those pillars doesn’t mean we’ve yet figured out how to keep them standing and stable over time.
随着开源软件（OSS）模式的不断发展和扩展到新的领域，以及许多流行项目的依赖图随着时间的推移不断扩大，<strong>依赖管理也许正在成为软件工程政策中最重要的问题</strong>。我们不再是建立在API之外的一两层上的不相连的岛屿。现代软件是建立在依赖关系的高大支柱上的；但是，<strong>我们能够建立这些支柱并不意味着我们已经弄清楚如何使它们长期屹立和稳定</strong>。</p>
</blockquote>
<blockquote>
<p>To some extent, this chapter is a summary of what we know does not work (or at least might not work at larger scales) and where we think there is the potential for better out‐ comes. We definitely cannot claim to have all the answers here; if we could, we wouldn’t be calling this one of the most important problems in software engineering.
在某种程度上，本章是对我们所知道的不起作用（或至少在更大范围内不起作用）以及我们认为有可能取得更好成果的地方的总结。我们绝对不能声称在这里有所有的答案；如果我们可以，我们就不会把这个问题称为软件工程中最重要的问题之一。</p>
</blockquote>
<blockquote>
<p>Systems of policy and technology for dependency management largely boil down to the question, “How do we avoid conflicting requirements while still allowing change among noncoordinating groups?”
依赖性管理的政策和技术体系在很大程度上归结为一个问题：&ldquo;我们如何避免冲突的需求，同时仍然允许非协调组之间的变化？&rdquo;</p>
</blockquote>
<blockquote>
<p>Source control (when you control the projects in question) is far easier than dependency management (when you don’t).
源头控制（当你控制有关项目时）远比依赖性管理（当你不控制时）容易。</p>
</blockquote>
<blockquote>
<p>When proposing solutions to dependency management, there are four common options that we know of that exhibit at least some of the appropriate properties: nothing ever changes, semantic versioning, bundle everything that you need (coordinating not per project, but per distribution), or Live at Head.
在提出依赖性管理的解决方案时，我们知道有四种常见的选择，它们至少表现出一些适当的属性：永远不改变、语义版本、捆绑你所需要的一切（不是按项目，而是按发行版），或 Live at Head。</p>
</blockquote>
<p>Minimum Version Selection(MVS): when liba’s specification requires libbase ≥1.7, we’ll try libbase 1.7 directly, even if a 1.8 is available.</p>
<blockquote>
<p>This is recognizing the core concern with SemVer, using MVS or not: there is some loss of fidelity in this compression of software changes into version numbers.
这就是认识到SemVer的核心问题，无论是否使用MVS：在这种将软件变化压缩为版本号的做法中，会有一些保真度的损失。</p>
</blockquote>
<blockquote>
<p>And thus, the model of dependency management given infinite resources is effectively that of the Live at Head model.
因此，在资源无限的情况下，依赖性管理的模式实际上就是 &ldquo;活在头上 &ldquo;的模式。</p>
</blockquote>
<blockquote>
<p>As the Apache community saying goes, we ought to priori‐ tize “community over code.” If you provide great code but are a poor community member, that can still be harmful to your organization and the broader community.
正如Apache社区的说法，我们应该优先考虑 &ldquo;社区大于代码&rdquo;。如果你提供了很好的代码，但却是一个糟糕的社区成员，这仍然会对你的组织和更广泛的社区造成伤害。</p>
</blockquote>
<p>gflags 的失败的开源故事。</p>
<blockquote>
<p>A dependency is a contract: there is a give and take, and both providers and con‐ sumers have some rights and responsibilities in that contract. Providers should be clear about what they are trying to promise over time.
依赖关系是一种合同：有付出就有收获，提供者和接受者在该合同中都有一些权利和责任。提供者应该清楚他们在一段时间内试图承诺什么。</p>
</blockquote>
<h2 id="22-大规模变更large-scale-changes-lsc">22. 大规模变更（Large-Scale Changes, LSC）</h2>
<blockquote>
<p>Today it is common for a double-digit percentage (10% to 20%) of the changes in a project to be the result of LSCs.
今天，一个项目中的两位数百分比（10%至20%）的变化是LSCs的结果，这很常见。</p>
</blockquote>
<blockquote>
<p>The largest series of LSCs ever executed removed more than one billion lines of code from the repository over the course of three days.
有史以来最大的一系列LSCs的执行，在三天的时间里从资源库中删除了超过10亿行的代码。</p>
</blockquote>
<blockquote>
<p>Socially, it’s important that code owners understand the changes happening to their software, but they also have come to realize that they don’t hold a veto over the broader LSC.
从社会角度来说，代码所有者了解发生在他们软件上的变化是很重要的，但他们也已经意识到，他们对更广泛的LSC并不拥有否决权。</p>
</blockquote>
<blockquote>
<p>We also use compiler-based indices to run abstract syntax tree-based analysis and transformations over our codebase. Tools such as ClangMR, JavacFlume, or Refaster.
我们还使用基于编译器的索引，在我们的代码库上运行基于抽象语法树的分析和转换。诸如ClangMR、JavacFlume或Refaster等工具。</p>
</blockquote>
<blockquote>
<p>At Google, as at most organizations, typical changes to the codebase are handcrafted by individual engineers working on specific features or bug fixes. &hellip; The creation of such a change is akin to owning and raising a favorite pet.
In contrast, effective handling of LSCs requires a high degree of automation and pro‐ duces an enormous number of individual changes. In this environment, we’ve found it useful to treat specific changes as cattle: nameless and faceless commits that might be rolled back or otherwise rejected at any given time with little cost unless the entire herd is affected.
With a “pet” commit, it can be difficult to not take rejection personally, but when working with many changes as part of a large-scale change, it’s just the nature of the job.
在谷歌，和大多数组织一样，代码库的典型变化是由从事特定功能或错误修复的个别工程师手工制作的。&hellip; 创建这样的变化就像拥有和养育一只喜爱的宠物一样。
相比之下，有效地处理LSCs需要高度的自动化，并产生大量的单独修改。在这种环境下，我们发现把特定的变化当作牛来对待是很有用的：无名无姓的提交，在任何时候都可能被回滚或以其他方式拒绝，除非整个牛群受到影响，否则代价很小。
对于一个 &ldquo;宠物 &ldquo;提交，不把拒绝当回事是很难的，但当作为大规模变革的一部分而处理许多变更时，这只是工作的自然性质。</p>
</blockquote>
<h2 id="23-持续集成ci">23. 持续集成（CI）</h2>
<blockquote>
<p>Having a 100% green rate on CI, just like having 100% uptime for a production service, is awfully expensive.
在CI上拥有100%的绿色率，就像生产服务拥有100%的正常运行时间一样，是非常昂贵的。</p>
</blockquote>
<blockquote>
<p>Policies that say, “Nobody can commit if our latest CI results aren’t green” are probably misguided. If CI reports an issue, such failures should definitely be investigated before letting people commit or compound the issue. But if the root cause is well understood and clearly would not affect production, blocking commits is unreasonable.
那些说 &ldquo;如果我们最新的CI结果不是绿色的，任何人都不能提交 &ldquo;的政策可能是被误导了。如果 CI 报告了一个问题，在让人们提交或使问题复杂化之前，肯定应该对这种失败进行调查。但如果根本原因已被充分理解，并且显然不会影响生产，那么阻止提交是不合理的。</p>
</blockquote>
<blockquote>
<p>These hotlists should be curated to make sure any release-blocking bugs are fixed immediately. Nonrelease blockers should be fixed, too; they are less urgent, but should also be pri‐ oritized so the test suite remains useful and is not simply a growing pile of disabled, old tests.
这些热名单应该被策划，以确保任何阻碍发布的错误被立即修复。非发布障碍也应该被修复；它们不那么紧急，但也应该被优先考虑，以便测试套件保持有用，而不是简单地成为一堆被禁用的旧测试。</p>
</blockquote>
<blockquote>
<p>To deal with such breakages, each team has a “Build Cop.” The Build Cop’s responsi‐ bility is keeping all the tests passing in their particular project, regardless of who breaks them.
为了处理这种破坏，每个团队都有一个 &ldquo;Build Cop&rdquo;。Build Cop的职责是在他们的特定项目中保持所有的测试通过，无论谁破坏它们。</p>
</blockquote>
<h2 id="24-持续发布cd">24. 持续发布（CD）</h2>
<blockquote>
<p>There is a saying among educators that no lesson plan survives its first contact with the student body. In much the same way, no software is perfect at first launch, and the only guarantee is that you’ll have to update it. Quickly.
在教育工作者中流传着这样一句话：没有一个教案能在与学生的第一次接触中幸存下来。同样地，没有一个软件在首次推出时是完美的，唯一的保证是你必须更新它。迅速。</p>
</blockquote>
<p>Faster is safer.</p>
<p>Isolation: strive for modular architecture to isolate changes and make troubleshooting easier.</p>
<blockquote>
<p>The rest of this book is arguably about minimizing the set of unintended outcomes for a release, but in the end we must admit that software is fundamentally complex.
本书的其余部分可以说是关于最大限度地减少发布时的一系列意外结果，但最后我们必须承认，软件从根本上说是复杂的。</p>
</blockquote>
<blockquote>
<p>Bloat is an unfortunate side effect of most software development life cycles, and the more successful a product becomes, the more bloated its code base typically becomes.
臃肿是大多数软件开发生命周期的一个不幸的副作用，一个产品越是成功，其代码库通常就越是臃肿。</p>
</blockquote>
<h2 id="25-云服务">25. 云服务</h2>
<blockquote>
<p>Easy things should be easy, and complex things should be possible.
简单的事情应该是容易的，而复杂的事情应该是可能的。</p>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exploring Writing foldl Using foldr]]></title>
    <link href="https://scturtle.me/posts/2016-01-27-foldl.html" />
    <published>2016-01-27T08:00:00+08:00</published>
    <updated>2016-01-27T08:00:00+08:00</updated>
    <id>https://scturtle.me/posts/2016-01-27-foldl.html</id>
    <content type="html"><![CDATA[<p>It is widely known that left folding can be implemented by right folding.
But the implementation is not so obvious. Let&rsquo;s try writing one from scratch.
First, we need these two extensions of GHC to make life better.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="font-style:italic">{-# LANGUAGE ScopedTypeVariables, PartialTypeSignatures #-}</span>
</span></span></code></pre></div><p>Let&rsquo;s just ignore the original implementations in <code>Prelude</code>
and try writing them by hand:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="font-weight:bold">import</span> <span style="font-weight:bold">Prelude</span> <span style="font-weight:bold">hiding</span> (foldr, foldl)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foldr <span style="font-weight:bold">::</span> (b <span style="font-weight:bold">-&gt;</span> a <span style="font-weight:bold">-&gt;</span> a) <span style="font-weight:bold">-&gt;</span> a <span style="font-weight:bold">-&gt;</span> [b] <span style="font-weight:bold">-&gt;</span> a
</span></span><span style="display:flex;"><span>foldr <span style="font-weight:bold">_</span> r <span style="">[]</span> <span style="font-weight:bold">=</span> r
</span></span><span style="display:flex;"><span>foldr f r (x<span style="">:</span>xs) <span style="font-weight:bold">=</span> f x (foldr f r xs)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>foldl <span style="font-weight:bold">::</span> (a <span style="font-weight:bold">-&gt;</span> b <span style="font-weight:bold">-&gt;</span> a) <span style="font-weight:bold">-&gt;</span> a <span style="font-weight:bold">-&gt;</span> [b] <span style="font-weight:bold">-&gt;</span> a
</span></span><span style="display:flex;"><span>foldl f r <span style="">[]</span> <span style="font-weight:bold">=</span> r
</span></span><span style="display:flex;"><span>foldl f a (x<span style="">:</span>xs) <span style="font-weight:bold">=</span> foldl f (f a x) xs
</span></span></code></pre></div><p>If we want to write <code>foldl</code> using <code>foldr</code>,
that defination should looks like this:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>foldl <span style="font-weight:bold">::</span> forall a b. (a <span style="font-weight:bold">-&gt;</span> b <span style="font-weight:bold">-&gt;</span> a) <span style="font-weight:bold">-&gt;</span> a <span style="font-weight:bold">-&gt;</span> [b] <span style="font-weight:bold">-&gt;</span> a
</span></span><span style="display:flex;"><span>foldl f i bs <span style="font-weight:bold">=</span> foldr undefined undefined undefined
</span></span></code></pre></div><p>The only thing we can be sure is that we will still be working on list <code>bs</code>.
So let&rsquo;s refine the above one with this observation:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>foldl <span style="font-weight:bold">::</span> forall a b. (a <span style="font-weight:bold">-&gt;</span> b <span style="font-weight:bold">-&gt;</span> a) <span style="font-weight:bold">-&gt;</span> a <span style="font-weight:bold">-&gt;</span> [b] <span style="font-weight:bold">-&gt;</span> a
</span></span><span style="display:flex;"><span>foldl f i bs <span style="font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">let</span> fold <span style="font-weight:bold">::</span> <span style="font-weight:bold">_</span> <span style="font-weight:bold">-&gt;</span> <span style="font-weight:bold">_</span> <span style="font-weight:bold">-&gt;</span> [b] <span style="font-weight:bold">-&gt;</span> <span style="font-weight:bold">_</span>
</span></span><span style="display:flex;"><span>      fold <span style="font-weight:bold">=</span> foldr
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">in</span>  fold undefined undefined bs
</span></span></code></pre></div><p>Let&rsquo;s think about a small example. According to our original implantation,
<code>foldl f i [b1, b2]</code> should be expanded into <code>f (f i b1) b2</code>
but the form in <code>foldr g j [b1, b2]</code> is <code>g b1 (b g2 j)</code>.
The most important step is the definition of <code>g</code> and <code>j</code>.
The function <code>g</code> should have type looks like <code>b -&gt; r -&gt; r</code> and
if the first parameter is <code>b1</code>, the second parameter (<code>r</code>) should
be able to use <code>f i b1</code> in itself to re-build the original <code>foldl</code> expansion.
That sounds like a continuation <code>a -&gt; r</code> instead of just <code>r</code>.
Let&rsquo;s try this idea:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>foldl <span style="font-weight:bold">::</span> forall a b. (a <span style="font-weight:bold">-&gt;</span> b <span style="font-weight:bold">-&gt;</span> a) <span style="font-weight:bold">-&gt;</span> a <span style="font-weight:bold">-&gt;</span> [b] <span style="font-weight:bold">-&gt;</span> a
</span></span><span style="display:flex;"><span>foldl f i bs <span style="font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">let</span> fold <span style="font-weight:bold">::</span> (b <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r) <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r)) <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r) <span style="font-weight:bold">-&gt;</span> [b] <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r)
</span></span><span style="display:flex;"><span>      fold <span style="font-weight:bold">=</span> foldr
</span></span><span style="display:flex;"><span>      g <span style="font-weight:bold">::</span> b <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r) <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r)
</span></span><span style="display:flex;"><span>      g b1 cont <span style="font-weight:bold">=</span> cont (f i b1)
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">in</span>  fold g undefined bs
</span></span></code></pre></div><p>Bad thing happens.
We get two type errors because now <code>g</code> and <code>fold</code> are of type ending with <code>(a -&gt; r)</code>.
Let&rsquo;s look into them one by one.
For <code>g</code>, we are using a <code>b</code> to turn a continuation into another continuation.
So <code>g</code> actually need a extra parameter <code>a</code>.
And <code>fold</code> return a continuation and need an initial value <code>a</code> to get the final result.
Let&rsquo;s refine the signature and definition:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>foldl <span style="font-weight:bold">::</span> forall a b. (a <span style="font-weight:bold">-&gt;</span> b <span style="font-weight:bold">-&gt;</span> a) <span style="font-weight:bold">-&gt;</span> a <span style="font-weight:bold">-&gt;</span> [b] <span style="font-weight:bold">-&gt;</span> a
</span></span><span style="display:flex;"><span>foldl f i bs <span style="font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">let</span> fold <span style="font-weight:bold">::</span> (b <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r) <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r)) <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r) <span style="font-weight:bold">-&gt;</span> [b] <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r)
</span></span><span style="display:flex;"><span>      fold <span style="font-weight:bold">=</span> foldr
</span></span><span style="display:flex;"><span>      g <span style="font-weight:bold">::</span> b <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r) <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r)
</span></span><span style="display:flex;"><span>      g b1 cont a <span style="font-weight:bold">=</span> cont (f i b1)
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">in</span>  fold g undefined bs undefined
</span></span></code></pre></div><p>Now our compiler warns us that <code>a</code> is not used.
According to its type, the only place to use it is where <code>i</code> is.
This makes sense because we are using the future result in our computation.
But where <code>i</code> should go? The only place seems to using it to complete our <code>fold</code>.
(I think this is the only tricky part and hope to find better thoughts on this in the future.)
Let&rsquo;s refine it again:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>foldl <span style="font-weight:bold">::</span> forall a b. (a <span style="font-weight:bold">-&gt;</span> b <span style="font-weight:bold">-&gt;</span> a) <span style="font-weight:bold">-&gt;</span> a <span style="font-weight:bold">-&gt;</span> [b] <span style="font-weight:bold">-&gt;</span> a
</span></span><span style="display:flex;"><span>foldl f i bs <span style="font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">let</span> fold <span style="font-weight:bold">::</span> (b <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r) <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r)) <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r) <span style="font-weight:bold">-&gt;</span> [b] <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r)
</span></span><span style="display:flex;"><span>      fold <span style="font-weight:bold">=</span> foldr
</span></span><span style="display:flex;"><span>      g <span style="font-weight:bold">::</span> b <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r) <span style="font-weight:bold">-&gt;</span> (a <span style="font-weight:bold">-&gt;</span> r)
</span></span><span style="display:flex;"><span>      g b1 cont a <span style="font-weight:bold">=</span> cont (f a b1)
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">in</span>  fold g undefined bs i
</span></span></code></pre></div><p>We are almost done and only one <code>undefined</code> is left.
Notice that the final result is of type <code>r</code> but our target type is <code>a</code>.
That just means <code>r</code> is <code>a</code>.
So the only left <code>undefined</code> is of type <code>forall a. a -&gt; a</code>
and its only implantation is <code>id</code> according to parametricity.
This also fits our experience with continuation by finishing it with <code>\a -&gt; a</code>.
Our final version is:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>foldl <span style="font-weight:bold">::</span> forall a b. (a <span style="font-weight:bold">-&gt;</span> b <span style="font-weight:bold">-&gt;</span> a) <span style="font-weight:bold">-&gt;</span> a <span style="font-weight:bold">-&gt;</span> [b] <span style="font-weight:bold">-&gt;</span> a
</span></span><span style="display:flex;"><span>foldl f i bs <span style="font-weight:bold">=</span>
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">let</span> g b1 cont a <span style="font-weight:bold">=</span> cont (f a b1)
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">in</span>  foldr g id bs i
</span></span></code></pre></div><p>It works!</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>λ&gt; foldl (\r x <span style="font-weight:bold">-&gt;</span> r ++ [x]) [0 <span style="font-weight:bold">::</span> <span style="">Int</span>] [1 .. 10]
</span></span><span style="display:flex;"><span>[0,1,2,3,4,5,6,7,8,9,10]
</span></span></code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PFPL 读书笔记和闲言碎语]]></title>
    <link href="https://scturtle.me/posts/2015-12-22-pfpl.html" />
    <published>2015-12-22T08:00:00+08:00</published>
    <updated>2015-12-22T08:00:00+08:00</updated>
    <id>https://scturtle.me/posts/2015-12-22-pfpl.html</id>
    <content type="html"><![CDATA[<p><a href="http://www.cs.cmu.edu/~rwh/plbook/1sted-revised.pdf">Practical Foundations for Programming Languages</a> 是一本介绍编程语言理论（PLT, programming language theory）和类型论（type theory）的书。
和另一本传说中的书 <a href="https://www.cis.upenn.edu/~bcpierce/tapl/">TAPL</a> 相比，更新内容也更广，不拘于一门编程语言，通篇的数学更简洁虽然也更难懂一些。
此外，在介绍的各种类型系统（type system）时，书里特意标出哪些规则是 call by name 那些是 call by value 的，很好地避免了单一一门语言对及早（eager）还是惰性求值的偏颇。
作者的大名也是不能更响，不管是第一版还是修订中的第二版都在网上放出 pdf 实属业界良心。</p>
<p>呃说起来 PLT 范围很广，从 Lisp/Scheme 的各种奇技淫巧，到 Haskell 从范畴论借来的各种花哨术语，再到不知何年何月才足够实用的 dependent type，摆脱不了的基础便是各种类型系统（type system）和背后的类型论了。
不过就像 PLT 其实没啥用处一样，看了这本书也并不会对写代码有什么帮助。
但是这本书会把各种语言的各种特性纳入一个统一的框架（类型论）中，告诉你哪些真能提升语言的表达能力，哪些特性是扯淡的，哪些看起来很绚丽的其实是另一些特性的组合。
了解这些呢有助于避免被某些新出语言的广告词所欺骗，也可以在永无停歇的语言互黑大战获得高屋建瓴一针见血的能力。</p>
<p>因为章节很碎（18部分，49章）,下面试图总结性地写一写，算是给自己的笔记，和近来多无所事事的交代。</p>
<p>Preface 有一句很有意思的话，感觉开了地图炮啊233：</p>
<blockquote>
<p>If language design and programming methodology are to advance from a trade-craft to a rigorous discipline, it is essential that we first get the definitions right.</p>
</blockquote>
<p>第一部分叫做 Judgments and Rules。基本上是各种常用的定义、符号和推导形式。呃其实就是证明论（proof theory）里那堆东西拿过来又叨叨了一遍。话说 proof theory、type theory 和 category theory 这三者虽然分别来自逻辑学、计算机和数学，但是现在互相打通（<a href="https://en.wikipedia.org/wiki/Cartesian_closed_category">CCC</a>, <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry–Howard correspondence</a>）之后来看，不得不说计算机还真是一门科学。作者本人也曾在讲座中 troll 过：</p>
<blockquote>
<p>Math itself is just a corner of computer science. Computer science is the queen of sciences. —— Robert Harper</p>
</blockquote>
<p>第二部分叫做 Statics and Dynamics。讲的是语言区分为静态部分和动态部分。
静态部分指语法和类型规则，语言在执行静态检查时会进行类型推断和检查，这时便可以剔除一些显而易见的类型错误。
动态规则指运行时如何从表达式一步一步运行得到值。
一个语言的类型系统既包括静态部分也包括动态部分，一个类型系统是否安全（type safety）也包括两个部分：preservation 和 progress。
前者要给你们看到，我静态分析这个表达式是这个类型，你动态运行每一步也是这个类型（没有特技）。
后者则是说，我静态检查通过了，你动态运行不会还没得到值就因为类型不符进行不下去了。
不过后者并不能排除除以零这种类型正确的运行时错误。
说起来静态部分做的工作越多，动态时出错的可能性也就更少，这也是为什么需要越来越高级的 type system 的原因。
不过到了 dependent type 这个地步，静态部分都不一定能停机了，还得程序员自己来证明并嵌入代码中，真的会有实用的一天么？……
最后这里还引用了一句著名广告词233：</p>
<blockquote>
<p>well-typed programs do not go wrong. —— Robin Milner</p>
</blockquote>
<p>第三部分叫做 Total Functions，引入了函数的定义和 system T。
在第二部分第四章介绍类型系统的时候，曾引入本书的的第一个类型系统 <code>language E</code>, 包括简单的数字、字符串、几个运算函数和 let 绑定。
这里先扩展 <code>E</code> 为 <code>ED</code> 添加了简单的函数定义和函数应用。
进而，引入 $\lambda$ function 并加入函数类型作为一等公民，实现了高阶函数（higher-order function），扩展 <code>E</code> 为 <code>EF</code>。
实现 $\lambda$ function 的时候，会有作用域的问题，解释时使用替换（substitution）没问题但是没嵌套作用域（nesting scoping）的 mapping environment 会有问题。
这也是为什么实际中实现 $\lambda$ function 需要闭包（closure）的原因。</p>
<p>System T 又叫做 Gödel&rsquo;s T，只包括包括上面的高阶函数和皮亚诺（Peano）数（<code>Z, S(Z), S(S(Z))</code>……）表示的自然数和原始递归（primitive recursion），是异常简单同时也非常重要的一个类型系统。
原始递归是建立在像剥洋葱一样层层剥离皮亚诺数基础上的递归，如果参数是 Z 也就是 0 的话就返回，如果是 S(e) 就对 e 继续递归。相当于每次递归的时候参数减一，所以是一定会停机的。
这说明 T 里面只能定义 total function，也就是像纯粹的数学函数一样，对定义域的每个输入都一定会返回值，而不会像 partial function 一样在某些定义域上未定义或者在计算中陷入了死循环。
（换句话说，system T 里的递归是自带 termination proof 的。）</p>
<p>咋一看这货根本不行啊，连一个最简单的死循环函数都写不出来啊。
文中用了的 Gödel&rsquo;s encoding 和对角线法（diagonalization）那套用来证明不完备的方法，来证明 T 中确实有无法定义的函数，比如一个自身的解释器，所以说 T 并不是图灵完备的。
可以说 system T 虽然抛弃了 universality 但是获得了 totality。
咋一看图灵完备都做不到有个毛用，但是 totality 在形式证明（formal proof）中却是必要的，因为一个不停机的证明什么也说明不了。
而且在 dependent type system 中，类型可能会依赖于值，所以 totality 对于类型检查能否停机也是至关重要的。
这也是 Coq、Idris 和 Agda 这类 <a href="http://www.wikiwand.com/en/Total_functional_programming">total functional programming</a> 的基础。</p>
<p>第四部分叫做 Finite Data Types。介绍了 product type 和 sum type 两种组合已有类型得到新类型的最基本的方法。
Product type 类比于常见的元祖（tuple）。比如（Int, String）这个类型的值的个数 = Int 的值得个数 $\times$ String 的值的个数。
那么乘法的单位元 $\mathfrak{1}$ 是什么呢？是空元祖类型也叫做 Unit，它的特点就是只有一个值 <code>()</code>。
Product type 有一个有趣的应用是可以用来实现像 odd 和 even 这种互相交叉定义的递归函数（primitive mutual recursion）。说白了就是递归时用元祖来同时计算所有函数啦。</p>
<blockquote>
<p>Sums codify heterogeneity.</p>
</blockquote>
<p>Sum type 则对应着类型“和”。比如 Haskell 里面的 <code>data Bool = True | False</code>，如果把 <code>True</code> 和 <code>False</code> 分别看做只有一个值的类型，那么 <code>Bool</code> 的值的个数就是 1+1=2。
另一个常见的 sum type 是 <code>data Maybe a = Nothing | Just a</code>（很多语言里面的 <code>option</code>），值的个数是类型 a 的值的个数加一。
“和”的单位元 $\mathfrak{0}$ 是类型 Void，其特点是……没有值，所以“加”什么还是什么。
这里的 Void 和 C/C++ 里面的 void 是不同的，后者其实是前面提到的 Unit，而前者没有任何值所以既不能被当做参数也不能被当做返回值（正常情况下……）。</p>
<!-- “null pointer fallacy” 不再赘述。 -->
<p>第五部分是 Types and Propositions。说的是 constructive logic（构造性逻辑，又叫 <a href="https://en.wikipedia.org/wiki/Intuitionistic_logic">intuitionistic logic</a>，直觉主义逻辑）和 <a href="https://en.wikipedia.org/wiki/Classical_logic">classical logic</a>（经典逻辑）之间的恩怨纠葛。
经典逻辑是我们熟悉的形式逻辑，包括命题为真，为假，和 $\top$ (truth), $\bot$ (falsity), $\vee$ (or), $\wedge$ (and), $\subset$ (imply)。
经典逻辑中任一命题要么为真要么为假，没有中间状态，叫做排中律（LEM, <a href="https://en.wikipedia.org/wiki/Law_of_excluded_middle">law of the excluded middle</a>），表示为 $P \vee \neg P\ true$。</p>
<blockquote>
<p>Constructive logic codiﬁes the principles of mathematical reasoning as it is actually practiced.</p>
</blockquote>
<p>构造性逻辑则拿掉了排中律，命题为真必须给出证明，为假则必须给出反驳，两者都必须构建在一个又一个的证明或者反驳之上。
比如，虽然我们知道要么 $P = NP$ 要么 $P \neq NP$，但是我们目前既不能给出前者的证明也给不出后者的证明（来反驳前者），所以不能用这两个证明中的任意一个来构建一个 $\vee$。
这样的好处是，构造性逻辑能更好地反映现实中的数学推理，现实中总是充满了各种未解决的问题，像 $P \stackrel{?}{=} NP$ 这种目前还只有上帝才知道，还是留给他老人家来用吧。</p>
<blockquote>
<p>There is no guarantee of success! Life is hard, but we muddle through somehow.</p>
</blockquote>
<p>另一方面，证明的构造性和计算机程序有着极其相似的结构，一个表达式对于一个特定的类型来说就像一个证明对于命题一样重要。
这种逻辑和程序奇妙的统一性叫做“propositions as type”。具体表现为：$\top$ 和 Unit，$\bot$ 和 Void，$\wedge$ 和 product，$\vee$ 和 sum，$\subset$ 和 $\lambda$ 分别是一一对应的。
一个命题对应一个类型，一个证明对应一个程序，又叫做 <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry-Howard correspondence</a>。</p>
<p>看似从经典逻辑中拿掉了不切实际的排中律，可以建立起逻辑和计算机之间深刻的联系，却必须以牺牲表达能力为代价，实际上并不是！
可以证明的是构造性逻辑 <em>不拒绝</em> 排中律。在需要的时候可以将特定命题的排中律拿来当假设用，所以经典逻辑完全可以在构造性逻辑中表达，只是不能随便开上帝模式了。
Mind blown! 后面还会继续出现这种 less is more 的栗子。</p>
<blockquote>
<p>In programming language terms adding a “feature” does not necessarily strengthen (improve the expressive power) of your language; on the contrary, it may weaken it.</p>
</blockquote>
<p>第六部分为 Infinite Data Types。
Generic programming 这章简单引入了带类型变量的 类型 $t.\tau$，叫做 polymorphic type operator。
其中 $\tau$ 是由 $t$ 和 void/unit/product/sum 组合的类型。
值得注意的是在扩展 $\tau$ 到函数时（$t.\ \tau_1 \rightarrow \tau_2$），需要保证 positivity 也就是 t 不能出现在定义域的位置（$\tau_1$），这种扩展和限制叫做 positive type operators。
其实这说的也就是 functor 和 fmap，引入这几个抽象概念是为了方便随后定义两种递归类型。</p>
<p>从名字就可以看出 Inductive types 和 coinductive types 是两个互为 dual 的概念。
前者定义在引进规则（introduction forms）上的，呃，就是定义在“怎么定义”上……
以其为参数的递归函数的一般形式（catamorphism）是先递归再替换。
举例来说皮亚诺数，每一个值要么是零要么是另一个值的后继。而参数是皮亚诺数的递归函数先在前驱上递归计算，再计算当前数上的值。
而 coindoctive types 定义在消除规则（elimination forms）上，嗯……算是“怎么来用”上……
以其为参数的的递归函数的一般形式（anamorphism）也相反，是先替换再递归。
通常拿来举的例子是一个无限的数据流（stream），比如斐波那契数列，每一项都是前两项的和，必须先计算完数列前面的值才能得到后面的值的数列。
如果说 inductive types 的函数更像传统意义上的递归函数（recursor）的话，那么 coinduvtive types 的函数则更像是根据指定规则的一个产生器（generator）。</p>
<p>这是两种最典型的递归形式（recursion scheme），区分它们的必要性在于，他们是同一个（关于 positive type operator 的）类型等式（type equations）的两个极端解（类型）。
例如 $x = 1 \times x$ 的 inductive/coinductive type 解分别是上面提到过的皮亚诺数和 infinity。
理论上来说 inductive types 是类型等式的最小解（smallest/least/most restrictive），而 coinductive types 是最大解（largest/greatest/most permissive）。
另一种对称性在于，前者虽然有无限个值，但是每一个值都是在有限步内构造的；而后者则构造了一个无限的序列，在有限步内析构会得到有限个值。
从刚才的例子还可以看出，假若不加区分的将一个前者的函数应用在后者上，就引发了死循环，所以强调 totality 的 Idris、Agda 等语言中显式地区分这两种概念。
从两者函数行为的区别上也可以看出，支持惰性求值才能支持先替换后递归，这也是为什么 Haskell 里面能这么简单实现无限序列的缘故。
（逼逼了这么多跟懂的似的不过下面这句话我到现在还不是很理解……）</p>
<blockquote>
<p>Inductive types are initial algebras and coinductive types are ﬁnal coalgebras for the functor given by a (polynomial or positive) type operator.</p>
</blockquote>
<p>第七部分叫做 Variable Types。
首先在 T 的基础上，引入了前一部分提到的类型变量和多态，得到 language F，也常常叫做 system F。
总的来说 system F 就是 <em>polymorphic</em> typed lambda-calculus。
多态（polymorphism）相比 OOP 里面那个含义更像 C++ 的模板系统，把类型无关的相似行为抽象出来，避免冗余代码。
比如 <code>id :: forall a. a -&gt; a</code>，不管输入是啥类型，给啥返回啥就好了。
多态大大地扩展了语言的表达能力，可以证明，前面提到过的 products/sums/inductive/coinductive types 都可以用多态函数来表示，这种表示法通常叫做 <a href="https://en.wikipedia.org/wiki/Church_encoding">Church encoding</a>，是丘奇为了证明他的$\lambda$演算的计算能力发明的。
例如自然数可以表示成 $\forall t.t \rightarrow (t \rightarrow t) \rightarrow t$，叫做<a href="https://zh.wikipedia.org/zh-hans/%E9%82%B1%E5%A5%87%E6%95%B0">丘奇数</a>。
不过多态的表达能力太过强大，已被证明，没有类型注释的 system F 的类型检查是 undecidable 的问题。
但是如果稍稍限制 <code>forall</code> 出现的位置，得到一个弱一点的 <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system">&ldquo;Hindley–Milner&rdquo;</a> 类型系统，甚至有高效的类型推断算法，是为 PLT 的经典算法之一。</p>
<p>注意到在 T 中自然数必须用皮亚诺表示法“硬编码”，这说明，F 至少和 T 的表达能力是一样的。
可以证明的是，虽然 T 的 evaluation function 不能在自身中实现，但是可以在 F 中实现，这说明 F 的表达能力是比 T 高的。
还可以证明 F 是强规范化的（strongly normalizing），也就是像 T 一样 terminating 的，所以 F 的 evaluation function 也不能用自身写出。
我们可以扩充 F 得到一个可以实现 F 的更强的语言，还可以进一步扩充这个语言得到更强一点的语言，但是只要是这些更强的语言都还是 terminating 的就还是不能实现自举（呃好像被最新的这篇 <a href="http://compilers.cs.ucla.edu/popl16/">paper</a> 打了脸，也就是说自举并不需要完备？）。
可以看出，虽然图灵完备的语言是相通的，图灵不完备的却有着表达能力阶层。</p>
<p>多态类型看似有着级大的自由度，实际上却很大程度上限制了其实现，这种特性叫做 parametricity，个人认为算是 PLT 里面最有意思的东西之一。
比如 <code>int -&gt; int</code> 这个函数可以有无数种实现，加一减一阶乘等等等等，但是一旦把类型抽象出来得到 <code>forall a. a -&gt; a</code>，要求其对所有类型 <code>a</code> 都适用，便只有 identity function <code>id</code> 这一种实现了。
这个函数签名可以读作“无论给一个什么东西（<code>a</code>），都得返回一个和这个东西 <em>所有性质</em>（of <code>a</code>）完全相同的东西”，所以只有直接返回一条路。
再一个例子是 <code>forall a. a -&gt; a -&gt; a</code>，给两个相同类型的参数返回相同类型的结果，可以证明的是只有返回第一个或者第二个两种实现。
看似极大自由 <code>forall</code> 却限制得连用 <code>if</code> 做个选择都不行。
更复杂的多态类型其性质的推导也更加复杂，本书倒数第二章详述了其后的理论，这里的<a href="http://www.well-typed.com/blog/2015/05/parametricity/">两篇实用的文章</a>比较容易入门。可以说，parametricity 才是类型系统确保程序正确性的根基：</p>
<blockquote>
<p>Parametricity narrows the space of well-typed programs sufﬁciently that the opportunities for programmer error are reduced to almost nothing.</p>
</blockquote>
<p>前面列举的类型中大量使用了 <code>forall</code>，如果将 polymorphic types 看成 universal types 的话，那么接下来的一章介绍的 existential types 算是其 dual 的概念了。
用文中常用的句型来说：Existential types <em>codify</em> data abstraction.
比如队列这个抽象类型可以有各种具体实现类型，每一种实现都可以看做队列的一种具体化的存在，可以拿来直接用。
实际上就是把实现和接口一块“打了个包”，要求的是接口的类型，用的时候实际上拿具体实现的类型和表达式做替换。</p>
<!-- 值得注意的是 data abstraction 的打包和替换都是在编译阶段完成的，没有运行时消耗。 -->
<p>看似 existential types 是 universal types 的 dual，其实 existential types 是完全可以用 universal types 来定义的！
这一章扩展了 F 得到 FE，并没有实际增加表达能力。</p>
<p>Type 也可以有 type，叫做 kind，前面提过的各种类型的 kind 可以看做 <code>*</code>，那么 type constructor 就是类型之上的函数，通过类型来构造新的类型，它的 kind 就是 <code>* -&gt; *</code>。
例如 <code>Maybe</code> 和 <code>[]</code>(list) 的 kind 是 <code>* -&gt; *</code> ，因为他们都需要指定一个元素类型，而 <code>Either</code> 的 kind 是 <code>* -&gt; * -&gt; *</code>。
接下来的一章扩展 F 加入 universal/existential quantifier 和 kind 得到 $F_\omega$。
因为 type constructor 涉及类型层面上的 $\lambda$-abstract 和 application，所以需要定义 definitional equality 来简化类型（类似 $\beta$-reduction）。
在 $F_\omega$ 的基础上，加上类型层面的存在量词就是 $FE_\omega$，不过不知道这东西有啥用……
$F_\omega$ 的表达能力很强大，是各种现代编译器的基础，人称 “the workhorse of modern compilers”，Haskell 的 type class、Ocaml 的 module system 甚至 GADT 都可以用它表示出来。
但是实际中也得加很多限制才能得到高效实用的算法。</p>
<p>第八部分是 Partiality and Recursive Types。
第十九章介绍了 <a href="https://en.wikipedia.org/wiki/Programming_Computable_Functions">system PCF</a>，最简单的图灵完备的类型系统，人称 “the E. coli of programming languages”。
System PCF 的表达能力来自 general recursion 和 partiality。
比如阶乘函数可以看做 fact(0)= 1 和 fact(n+1) = (n+1) * fact(n) 这两个等式的解 fact :: Nat -&gt; Nat，这个解可以通过不动点来求得。
假设我们已经有 fact 这个解了，那么我们可以写这么一个辅助函数：
f(fact) = $\lambda$ n -&gt; if n == 0 then 1 else n * fact(n-1)。
显然等式 fact = f(fact) 成立，假设我们有一个求函数不动点的函数 fix，那么 fact = fix(f)。
为何不动点就是我们要的解呢？
因为 PCF 里面的函数是 partial 的，允许函数在有的输入上未定义（发散/不终止），所以我们可以先试着传给 f 一个非常垃圾的解，比如一个在所有输入上都不终止的函数 $\phi$。
神奇的事情发生了！$\phi&rsquo;$ = f($\phi$) 在 0 这个 base case 上不依赖于 $\phi$ 返回了结果 1，虽然在其他输入上还是发散了。
按照不动点的含义，我们再把 $\phi&rsquo;$ 喂给 f 得到 $\phi&rsquo;&rsquo;$ = f($\phi&rsquo;$) = f(f($\phi$))。
神奇的事情再次发生了！因为 $\phi&rsquo;$ 在 0 上有了定义，现在 $\phi&rsquo;&rsquo;$ 在 1 上也有了定义。
因为 base case 的存在，我们就像求不动点一样不断把更好地解传给 f，就可以不断逼近一个我们想要的 total function。
实际中 fix 函数的实现也是异曲同工。</p>
<p>可以证明的是 PCF 可实现所有 <a href="https://en.wikipedia.org/wiki/%CE%9C-recursive_function">partial recursive functions</a>（主要是可以实现 minimization/$\mu$ operation），而且 PCF 自身的 evaluator 也可以用 partial recursive functions 来表示，可见 PCF 是自举的。
由<a href="https://en.wikipedia.org/wiki/Computable_function#Definition">等价性</a>可知 PCF 是和图灵机/lambda calculus 等价的。
前面提过 T 中程序的终止的证明是“编码”进代码和类型检查中的，可想而知而有了 partial functions 抛弃了 totality 之后，写能通过类型检查的程序也更简单了。
甚至有一个定理 <a href="https://en.wikipedia.org/wiki/Blum%27s_speedup_theorem">Blum Size Theorem</a> 指出，总存在一个函数在任何 total 的语言中的最短实现是 PCF 中的最短实现的 <em>任意多倍</em>。</p>
<p>下一章介绍了递归类型（recursive types），扩展 PCF 得到 FPC（这两名字为什么这么像？）。
我们熟悉的 list 啊 tree 啊这些都是典型的递归类型。
递归类型和前述的 inductive/coinductive types 定义几乎相同，只是拿掉了 positivity 限制。
前面提过 inductive/coinductive types 可以看做是 positive 的类型等式的解，那么递归类型则是拿掉了 positivity 限制的类型等式的解。
但是去掉了限制后解不一定存在，所以递归类型算是一种不动点近似解，也是唯一解，前述的 inductive/coinductive 之分体现在对递归类型的及早/惰性求值上。
这里十分不解的是作者说用很大的篇幅说及早求值比惰性求值表达能力要高，因为前者能表示用函数来表示后者，而后者不能表示前者？谨慎持异议……
此外，前述的通用递归（general recursion）可以用递归类型表示出来，因为两者都是靠的自指（self-reference），所以扩充语言表达能力的不是语言特性，最终还是类型。</p>
<p>(待续……)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Yoneda Lemma Explained in Haskell]]></title>
    <link href="https://scturtle.me/posts/2015-06-16-yoneda.html" />
    <published>2015-06-16T08:00:00+08:00</published>
    <updated>2015-06-16T08:00:00+08:00</updated>
    <id>https://scturtle.me/posts/2015-06-16-yoneda.html</id>
    <content type="html"><![CDATA[<blockquote>
<p>When you need something to go faster, hit it with the Yoneda lemma.
Still isn&rsquo;t fast enough? Use it again.
—— <a href="https://twitter.com/kmett/status/546533863636627456">Edward Kmett</a></p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Yoneda_lemma">Yoneda lemma</a>
may be the first understanding challenge in category theory.
For an arbitrary functor $F$ from a category $C$ to the category $Set$,
Yoneda lemma says:
for any object $A$ of $C$, the natural transformations from
the <a href="http://ncatlab.org/nlab/show/hom-functor">hom-functor</a> $h_A$ to $F$
are in one-to-one correspondence with the elements in $F(A)$.
That&rsquo;s is,</p>
<p>$$ \mathrm{Nat}(h_A,F) \cong F(A). $$</p>
<p>Doesn&rsquo;t it hurt your brain? The proof is even more tedious.
In another way, however, it just states that every object
can be determined by how other objects map into it.
The interesting thing is, once translated into Haskell,
the Yoneda lemma becomes more readable and understandable.</p>
<p>In Haskell the category $C$ and $Set$ are both $Hask$,
the category of all types in Haskell.
And a natural transformation is just a polymorphic function which,
in this case, from functor <code>(-&gt;) a</code> to functor <code>f</code>.
So in Haskell we can write Yoneda lemma as</p>
<pre><code>(forall b. (a -&gt; b) -&gt; f b) ~ f a
</code></pre>
<p>which means an isomorphism between a polymorphic function and a type.
This can be interpreted in the following way: for a fixed type <code>a</code> and a functor <code>f</code>,
if there is a polymorphic function <code>g</code> that knows how to convert any <code>a -&gt; b</code> into <code>f b</code>,
then this <code>g</code> is just something holding a <code>f a</code>
(and remembering to <code>fmap</code> any <code>a -&gt; b</code> on it), and vice versa.</p>
<p>To prove this isomorphism, we need to show that for the following two conversion functions:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span>fw <span style="font-weight:bold">::</span> (<span style="">Functor</span> f) <span style="font-weight:bold">=&gt;</span> (forall b . (a <span style="font-weight:bold">-&gt;</span> b) <span style="font-weight:bold">-&gt;</span> f b) <span style="font-weight:bold">-&gt;</span> f a
</span></span><span style="display:flex;"><span>fw f <span style="font-weight:bold">=</span> f id
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bw <span style="font-weight:bold">::</span> (<span style="">Functor</span> f) <span style="font-weight:bold">=&gt;</span> f a <span style="font-weight:bold">-&gt;</span> (forall b . (a <span style="font-weight:bold">-&gt;</span> b) <span style="font-weight:bold">-&gt;</span> f b)
</span></span><span style="display:flex;"><span>bw x f <span style="font-weight:bold">=</span> fmap f x
</span></span></code></pre></div><p>the following two statements are both true:</p>
<pre tabindex="0"><code>fw . bw = id
bw . fw = id
</code></pre><p>The first one is easy:</p>
<pre tabindex="0"><code>(fw . bw) fa
= fw (bw fa)
= (bw fa) id
= bw fa id
= fmap id fa
= fa
</code></pre><p>and there are two steps notable in the second proof:</p>
<pre tabindex="0"><code>bw (fw g) a2b
= fmap a2b (g id)
= g (fmap a2b id) (*)
= g (a2b . id)    (**)
= g a2b
</code></pre><p>In <code>(*)</code> we swap <code>g</code> and <code>fmap a2b</code> when apply them to <code>id</code> in sequence.
This is because the <code>forall</code> in the polymorphic function <code>g</code>
makes it a natural transformation from functor <code>(-&gt; a)</code> to functor <code>f</code>
and ensure that the following diagram commute:</p>
<pre tabindex="0"><code>                  g
      (a -&gt; b) --------&gt; f b
         ^                ^
         |                |
fmap a2b |                | fmap a2b
         |                |
         |                |
      (a -&gt; a) --------&gt; f a
                  g
</code></pre><p>Commutation means the both ways from bottom left to top right are the same.
So we can swap <code>g</code> and <code>fmap a2b</code>. Also notice that the bottom left is just <code>id</code>.
The <code>(**)</code> step is an application of the <code>fmap</code> definition of functor <code>(-&gt; a)</code>,
which is just function composition <code>(.)</code>. QED.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[字符串搜索的 Horspool 算法]]></title>
    <link href="https://scturtle.me/posts/2015-03-14-horspool.html" />
    <published>2015-03-14T08:00:00+08:00</published>
    <updated>2015-03-14T08:00:00+08:00</updated>
    <id>https://scturtle.me/posts/2015-03-14-horspool.html</id>
    <content type="html"><![CDATA[<blockquote>
<p>当你要手写一个字符串搜索算法，你会写什么？</p>
</blockquote>
<p>本文将要介绍的 Horspool 算法简单又不慢，一看就懂，一学就会，一写就过！</p>
<p>假设我们要在一个叫 haystack 的字符串中搜索另一个叫 needle 的字符串。先对齐，从后往前搜到某个不匹配的字符：</p>
<pre>
ab<font color=red>c</font><font color=green>bab</font>ababab
cb<font color=red>a</font><font color=green>bab</font>
</pre>
<p>我们可以把 needle 右移一位然后重新从最后一个开始匹配，这是最朴素的算法。但是我们可不可以多移几位呢？我们看 haystack 中的第三个 b，一个策略是移动 needle 使得这个 b 和 needle 里倒数第二个 b 对齐来，这样 needle 移了两个位置。</p>
<pre>
abcba<font color=green>b</font>ababab
  cba<font color=green>b</font>ab
</pre>
<p>needle 里第一个 b 不行，因为会错过解；最后一个 b 也不行，因为 needle 没有动。所以除了 needle 里最后一个位置之外，倒数第一个配对的字符才是正确的选择。</p>
<p>所以我们知道如何预处理一下 needle，记录 <strong>needle 每个字符的倒数第一次出现的位置(末尾除外)离 needle 末尾的距离</strong>，来作为跳转步数。不在 needle 里出现的字符对应的跳转步数则为 |needle|。哎呀这个岂不很好写的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="">int</span> jmp_table[UCHAR_MAX+1];
</span></span><span style="display:flex;"><span><span style="font-weight:bold">for</span>(<span style="">int</span> i = 0; i &lt;= UCHAR_MAX; i++)
</span></span><span style="display:flex;"><span>  jmp_table[i] = nlen;
</span></span><span style="display:flex;"><span><span style="">int</span> last = nlen - 1;
</span></span><span style="display:flex;"><span><span style="font-weight:bold">for</span>(<span style="">int</span> i = 0; i &lt; last; i++)
</span></span><span style="display:flex;"><span>  jmp_table[needle[i]] = last - i;
</span></span></code></pre></div><p>好了现在我们知道，每次出现不匹配时，找到 haystack 里和 needle 对应的最后一个字符，再在 needle 里找它倒数第一次出现的位置(末尾除外)，然后把它们对齐。就是这么简单。</p>
<p>完整的 C++ 代码：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="">int</span> horspool(<span style="">char</span> *haystack, <span style="">char</span> *needle) {
</span></span><span style="display:flex;"><span>  <span style="">int</span> hlen = strlen(haystack), nlen = strlen(needle);
</span></span><span style="display:flex;"><span>  <span style="">int</span> jmp_table[UCHAR_MAX+1];
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">for</span>(<span style="">int</span> i = 0; i &lt;= UCHAR_MAX; i++)
</span></span><span style="display:flex;"><span>    jmp_table[i] = nlen;
</span></span><span style="display:flex;"><span>  <span style="">int</span> last = nlen - 1;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">for</span>(<span style="">int</span> i = 0; i &lt; last; i++)
</span></span><span style="display:flex;"><span>    jmp_table[needle[i]] = last - i;
</span></span><span style="display:flex;"><span>  <span style="">int</span> j = 0;
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">while</span>(j &lt;= hlen - nlen){
</span></span><span style="display:flex;"><span>    <span style="">char</span> c = haystack[j + last];
</span></span><span style="display:flex;"><span>    <span style="">int</span> i = last;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">while</span>(i &gt;= 0 &amp;&amp; haystack[j + i] == needle[i]) --i;
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">if</span>(i == -1) <span style="font-weight:bold">return</span> j;
</span></span><span style="display:flex;"><span>    j += jmp_table[c];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">return</span> -1;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>简单到 Haskell 的也很好写哇：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-haskell" data-lang="haskell"><span style="display:flex;"><span><span style="font-style:italic">{-# LANGUAGE OverloadedStrings #-}</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">import</span> <span style="font-weight:bold">qualified</span> <span style="font-weight:bold">Data.Map</span> <span style="font-weight:bold">as</span> M (findWithDefault, fromList)
</span></span><span style="display:flex;"><span><span style="font-weight:bold">import</span> <span style="font-weight:bold">qualified</span> <span style="font-weight:bold">Data.ByteString</span> <span style="font-weight:bold">as</span> BS
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>horspool <span style="font-weight:bold">::</span> <span style="">BS</span>.<span style="">ByteString</span> <span style="font-weight:bold">-&gt;</span> <span style="">BS</span>.<span style="">ByteString</span> <span style="font-weight:bold">-&gt;</span> <span style="">Maybe</span> <span style="">Int</span>
</span></span><span style="display:flex;"><span>horspool s p <span style="font-weight:bold">=</span> f (lenp - 1) (lenp - 1) (lenp - 1)
</span></span><span style="display:flex;"><span>  <span style="font-weight:bold">where</span> lenp <span style="font-weight:bold">=</span> <span style="">BS</span>.length p
</span></span><span style="display:flex;"><span>        lens <span style="font-weight:bold">=</span> <span style="">BS</span>.length s
</span></span><span style="display:flex;"><span>        jmptbl <span style="font-weight:bold">=</span> <span style="">M</span>.fromList $ zip (<span style="">BS</span>.unpack p) [lenp - 1, lenp - 2 .. 1]
</span></span><span style="display:flex;"><span>        jmp x <span style="font-weight:bold">=</span> <span style="">M</span>.findWithDefault lenp x jmptbl
</span></span><span style="display:flex;"><span>        f i j k
</span></span><span style="display:flex;"><span>          | i &gt;= lens <span style="font-weight:bold">=</span> <span style="">Nothing</span>
</span></span><span style="display:flex;"><span>          | j == -1 <span style="font-weight:bold">=</span> <span style="">Just</span> (i + 1)
</span></span><span style="display:flex;"><span>          | s `<span style="">BS</span>.index` i == p `<span style="">BS</span>.index` j <span style="font-weight:bold">=</span> f (i-1) (j-1) k
</span></span><span style="display:flex;"><span>          | otherwise <span style="font-weight:bold">=</span> <span style="font-weight:bold">let</span> k&#39; <span style="font-weight:bold">=</span> k + jmp (s `<span style="">BS</span>.index` k)
</span></span><span style="display:flex;"><span>                         <span style="font-weight:bold">in</span> f k&#39; (lenp - 1) k&#39;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>main <span style="font-weight:bold">::</span> <span style="">IO</span> ()
</span></span><span style="display:flex;"><span>main <span style="font-weight:bold">=</span> print $ horspool <span style="font-style:italic">&#34;abcbabababab&#34;</span> <span style="font-style:italic">&#34;cbabab&#34;</span>
</span></span></code></pre></div>]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 字符串格式化详参]]></title>
    <link href="https://scturtle.me/posts/2013-12-19-string-format-python.html" />
    <published>2013-12-19T08:00:00+08:00</published>
    <updated>2013-12-19T08:00:00+08:00</updated>
    <id>https://scturtle.me/posts/2013-12-19-string-format-python.html</id>
    <content type="html"><![CDATA[<p><a href="http://docs.python.org/dev/library/string.html#formatspec">来源docs</a></p>
<p><code>{}</code> 包裹的是替换域，{% raw %} <code>{{</code> 和 <code>}}</code> {% endraw %} 可用来 escape。</p>
<p>语法</p>
<pre tabindex="0"><code>替换域 ::=  &#34;{&#34; [域名] [&#34;!&#34; 转换] [&#34;:&#34; 格式] &#34;}&#34;
域名   ::=  参数名 (&#34;.&#34; 属性名 | &#34;[&#34; 索引 &#34;]&#34;)*
参数名 ::=  [关键字 | 数字]
属性名 ::=  关键字
索引   ::=  数字 | 索引字符串
索引   ::=  &lt;任何字符除了 &#34;]&#34;&gt; +
转换   ::=  &#34;r&#34; | &#34;s&#34; | &#34;a&#34;
格式   ::=  &lt;如下介绍&gt;
</code></pre><p>参数名要么是关键字（keyword=“&hellip;”）要么是数字（标识第几个参数，3.1中默认可忽略）。
参数名后可加 <code>.属性名</code>（<code>getattr()</code>）或 <code>[索引]</code>（<code>__getitem__()</code>）。</p>
<p>转换域进行格式化之前的强制类型转换（而不是默认的<code>__format__()</code>）。<code>!s</code> 调用 <code>str()</code>，<code>!r</code> 调用 <code>repr()</code>，<code>!a</code> 调用 <code>ascii()</code>。</p>
<p>格式域控制字段宽度，对齐，填充，小数精度等。依据是每种类型自己定义的<code>微语言</code>。格式域可嵌套但只能包含域名。大多数内置类型支持默认的微语言：</p>
<pre tabindex="0"><code>格式 ::=  [[fill]align][sign][#][0][width][,][.precision][type]
fill     ::=  &lt;填充字符除了 &#39;{&#39; or &#39;}&#39;&gt;
align ::=  &#34;&lt;&#34; | &#34;&gt;&#34; | &#34;=&#34; | &#34;^&#34;
sign  ::=  &#34;+&#34; | &#34;-&#34; | &#34; &#34;
width ::=  integer
precision ::=  integer
type ::=  &#34;b&#34; | &#34;c&#34; | &#34;d&#34; | &#34;e&#34; | &#34;E&#34; | &#34;f&#34; | &#34;F&#34; | &#34;g&#34; | &#34;G&#34; | &#34;n&#34; | &#34;o&#34; | &#34;s&#34; | &#34;x&#34; | &#34;X&#34; | &#34;%&#34;
</code></pre><p>align：左对齐，右对齐，填充符号和数字间，居中。</p>
<p>sign：正数前+负数前-，正数前无负数前-，正数前空格负数前-。</p>
<p>#：整数、浮点数、复数和 Decimal 使用<code>替代格式</code>。比如整数在用十六进制输出时添加<code>0x</code>前缀。</p>
<p>width：前导<code>0</code>则相当于<code>fill='0' &amp; align='='</code>。</p>
<p>,：数字自动添加千分号。</p>
<p>precision：和<code>type = &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot;</code>控制浮点精度，或表示最大域空间。</p>
<p>type：二进制，字符，十进制，科学计数，科学计数大写，定点，定点(NAN, INF)，
<em>标准格式（太长）</em>，标准格式大写，<em>数字</em>，八进制，十六进制，十六进制大写，百分比。
不写的话整数十进制，浮点数差不多是标准格式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Average Running Time of Quicksort]]></title>
    <link href="https://scturtle.me/posts/2013-11-09-quicksort.html" />
    <published>2013-11-09T08:00:00+08:00</published>
    <updated>2013-11-09T08:00:00+08:00</updated>
    <id>https://scturtle.me/posts/2013-11-09-quicksort.html</id>
    <content type="html"><![CDATA[<p>From an interesting <a href="http://aofa.cs.princeton.edu/lectures/lectures13/AA01-AofA.pdf">slide</a>.</p>
<p>We denote $C_N$ as the <em>expected</em> number of comparisons used by sorting an array of length $N$.
The recursive formula is like this:</p>
<p>$$C_N = (N+1) + \sum_{1\leq k \leq N} \frac 1N (C_{k-1}+C_{N-k})$$</p>
<p>which $N+1$ is the comparisons needed for partitioning,
and then plus $N$ ways of partitioning with equal probability.
Also we have $C_1 = 0$.</p>
<p>Noticing the symmetric parttern in the sum part, we get:</p>
<p>$$C_N = (N+1) + \frac 2N \sum_{1\leq k \leq N} C_{k-1}$$</p>
<p>then</p>
<p>$$NC_N = N(N+1) + 2 \sum_{1\leq k \leq N} C_{k-1}$$</p>
<p>Time to high school math. First, we write down same formula for N-1:</p>
<p>$$(N-1)C_{N-1} = (N-1)N + 2 \sum_{1\leq k \leq N-1} C_{k-1}$$</p>
<p>Then we subtract the above two equations to get:</p>
<p>$$NC_N - (N-1)C_{N-1} = 2N + 2C_{N-1}$$</p>
<p>$$NC_N = (N+1)C_{N-1} + 2N$$</p>
<p>Key and tricky step, divide both side by $N(N+1)$:</p>
<p>$$\frac{C_N}{N+1} = \frac{C_{N-1}}{N} + \frac{2}{N+1}$$</p>
<p>Expand the right part to the end of the world:</p>
<p>$$\begin{split}
\frac{C_N}{N+1} &amp;= \frac{C_{N-1}}{N} + \frac 2{N+1} \
&amp;= \frac{C_{N-2}}{N-1} + \frac 2N + \frac 2{N+1} \
&amp;= \frac {C_1} 2 + \frac 23 + \dots + \frac 2N + \frac 2{N+1}
\end{split}$$</p>
<p>Ignore small items:</p>
<p>$$c_N \sim 2N \sum_{1 \leq k \leq N} \frac 1k - 2N$$</p>
<p>Finally, use the magic <a href="http://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant"><code>Euler constant</code></a> $\gamma$ = 0.57721&hellip;:</p>
<p>$$\begin{split}
c_N &amp;\sim 2N (\int_1^\infty \frac 1x \mathrm{d} x + \gamma) - 2N \
&amp;=2N \ln N - 2(1-\gamma)N
\end{split}$$</p>
<p>It&rsquo;s $O(N \log N)$.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Random Sampling]]></title>
    <link href="https://scturtle.me/posts/2013-04-17-random-sampling.html" />
    <published>2013-04-17T08:00:00+08:00</published>
    <updated>2013-04-17T08:00:00+08:00</updated>
    <id>https://scturtle.me/posts/2013-04-17-random-sampling.html</id>
    <content type="html"><![CDATA[<p>Given a set of items, choosing random one with equal probability can be done by <code>random.choice(items)</code>.
But what if we are given items one by one without knowing the length of the whole set?</p>
<p>There is a simple algorithm: For the $k$-th item, we give up previous selection and choose this one with probability $\frac 1 k$.
Proof as follows: If we select the $k$-th item, it means that we choose it with probability $\frac 1 k$ and give up all successors.
Product of probabilities of all these choices is:</p>
<p>$$ p_k = \frac 1 k \times \frac {k} {k+1} \times \cdots \times \frac {n-2}{n-1} \times \frac {n-1} n = \frac 1 n $$</p>
<p>Codes in Python:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="font-weight:bold">import</span> <span style="font-weight:bold">random</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">def</span> choice(items):
</span></span><span style="display:flex;"><span>    selection = <span style="font-weight:bold">None</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> i, item <span style="font-weight:bold">in</span> enumerate(items):
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> random.randint(0, i) == 0:
</span></span><span style="display:flex;"><span>            selection = item
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> selection
</span></span></code></pre></div><p>We can generalize this algorithm. For a set of items, each one is associated with a weight $w_i$.
Our goal is to select a random one based on its weight ratio.
The algorithm is similar to the previous one: For the $k$-th item, replace the current selection with it with probability $\frac {w_k} {\sum_{i=1}^k w_i}$.
Proof is analogical:</p>
<p>$$p_k = \frac {w_k} {\sum_{i=1}^k w_i} \times \frac {\sum_{i=1}^k w_i} {\sum_{i=1}^{k+1} w_i}
\times \cdots \times \frac {\sum_{i=1}^{n-2} w_i} {\sum_{i=1}^{n-1} w_i} \times \frac {\sum_{i=1}^{n-1} w_i} {\sum_{i=1}^{n} w_i} = \frac {w_k} {\sum_{i=1}^n w_i}$$</p>
<p>Codes in Python:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="font-weight:bold">def</span> weightedChoice(items, weights):
</span></span><span style="display:flex;"><span>    selection = <span style="font-weight:bold">None</span>
</span></span><span style="display:flex;"><span>    total_weight = 0.0
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">for</span> item, weight <span style="font-weight:bold">in</span> zip(items, weights):
</span></span><span style="display:flex;"><span>        total_weight += weight
</span></span><span style="display:flex;"><span>        <span style="font-weight:bold">if</span> random.random() * total_weight &lt; weight:
</span></span><span style="display:flex;"><span>            selection = item
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">return</span> selection
</span></span></code></pre></div><p>There is another amazing method to do this weighted random sampling:
For each item, get a random $r_i \in [0, 1]$,
and <em>reweight</em> this item as $w&rsquo;_i = r_i^{1 / {w_i}}$.
Then we can select the one with the top new weight. Proof of this is a bit annoying.</p>
<p>If we choose the $i$-th item at last, this means $\forall j\neq i, w&rsquo;_j &lt;w&rsquo;_i$. As $r_i \in [0, 1]$, the probability is:</p>
<p>$$ p_i = \int_0^1 p(\forall j\neq i, w&rsquo;_j &lt;w&rsquo;_i)\ \mathrm{d}\ r_i $$</p>
<p>$r_j$ is independent with each other. So:</p>
<p>$$ p_i = \int_0^1 \prod_{j \neq i} p(w&rsquo;_j &lt;w&rsquo;_i)\ \mathrm{d} \ r_i $$</p>
<p>As $r_j \in [0, 1]$, the inner probability can be simplified as:</p>
<p>$$ p(w&rsquo;_j &lt;w&rsquo;_i) = p(r_j^{1 / w_j} &lt; r_i^{1 / w_i}) = p(r_j &lt; r_i^{w_j / w_i}) = r_i^{w_j / w_i} $$</p>
<p>So:</p>
<p>$$ p_i = \int_0^1 \prod_{j \neq i} r_i^{w_j / w_i}\ \mathrm{d}\ r_i
= \int_0^1 r_i^{(w-w_i) / w_i}\ \mathrm{d}\ r_i = \frac {w_i} w $$</p>
<p>Same as our expectation.</p>
<p>This blog is basically a summary of
<a href="http://www.gocalf.com/blog/random-selection.html">these</a>
<a href="http://www.gocalf.com/blog/weighted-random-selection.html">three</a>
<a href="http://www.gocalf.com/blog/weighted-random-selection-2.html">blogs</a>.
Refer to them for more content.</p>
]]></content>
  </entry>
  
</feed>
