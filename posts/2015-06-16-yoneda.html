<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Yoneda Lemma Explained in Haskell | turtleblog</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="Yoneda Lemma Explained in Haskell">
<meta name="author" content="scturtle">
<meta property="og:locale" content="en_US">
<meta name="description" content="When you need something to go faster, hit it with the Yoneda lemma. Still isn’t fast enough? Use it again. —— Edward Kmett">
<meta property="og:description" content="When you need something to go faster, hit it with the Yoneda lemma. Still isn’t fast enough? Use it again. —— Edward Kmett">
<meta property="og:site_name" content="turtleblog">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2015-06-16T00:00:00+08:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Yoneda Lemma Explained in Haskell">
<script type="application/ld+json">
{"headline":"Yoneda Lemma Explained in Haskell","dateModified":"2015-06-16T00:00:00+08:00","datePublished":"2015-06-16T00:00:00+08:00","url":"/posts/2015-06-16-yoneda.html","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/2015-06-16-yoneda.html"},"author":{"@type":"Person","name":"scturtle"},"description":"When you need something to go faster, hit it with the Yoneda lemma. Still isn’t fast enough? Use it again. —— Edward Kmett","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css">
<link type="application/atom+xml" rel="alternate" href="/feed.xml" title="turtleblog">
<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]]}});</script>
</head>
<body>
<header class="site-header">

  <div class="wrapper">
<a class="site-title" rel="author" href="/">turtleblog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Yoneda Lemma Explained in Haskell</h1>
    <p class="post-meta"><time class="dt-published" datetime="2015-06-16T00:00:00+08:00" itemprop="datePublished">
        Jun 16, 2015
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <blockquote>
  <p>When you need something to go faster, hit it with the Yoneda lemma.
Still isn’t fast enough? Use it again.
—— <a href="https://twitter.com/kmett/status/546533863636627456">Edward Kmett</a></p>
</blockquote>

<p><a href="https://en.wikipedia.org/wiki/Yoneda_lemma">Yoneda lemma</a>
may be the first understanding challenge in category theory.
For an arbitrary functor $F$ from a category $C$ to the category $Set$,
Yoneda lemma says:
for any object $A$ of $C$, the natural transformations from
the <a href="http://ncatlab.org/nlab/show/hom-functor">hom-functor</a> $h_A$ to $F$
are in one-to-one correspondence with the elements in $F(A)$.
That’s is,</p>

\[\mathrm{Nat}(h_A,F) \cong F(A).\]

<p>Doesn’t it hurt your brain? The proof is even more tedious.
In another way, however, it just states that every object
can be determined by how other objects map into it.
The interesting thing is, once translated into Haskell,
the Yoneda lemma becomes more readable and understandable.</p>

<p>In Haskell the category $C$ and $Set$ are both $Hask$,
the category of all types in Haskell.
And a natural transformation is just a polymorphic function which,
in this case, from functor <code class="language-plaintext highlighter-rouge">(-&gt;) a</code> to functor <code class="language-plaintext highlighter-rouge">f</code>.
So in Haskell we can write Yoneda lemma as</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(forall b. (a -&gt; b) -&gt; f b) ~ f a
</code></pre></div></div>

<p>which means an isomorphism between a polymorphic function and a type.
This can be interpreted in the following way: for a fixed type <code class="language-plaintext highlighter-rouge">a</code> and a functor <code class="language-plaintext highlighter-rouge">f</code>,
if there is a polymorphic function <code class="language-plaintext highlighter-rouge">g</code> that knows how to convert any <code class="language-plaintext highlighter-rouge">a -&gt; b</code> into <code class="language-plaintext highlighter-rouge">f b</code>,
then this <code class="language-plaintext highlighter-rouge">g</code> is just something holding a <code class="language-plaintext highlighter-rouge">f a</code>
(and remembering to <code class="language-plaintext highlighter-rouge">fmap</code> any <code class="language-plaintext highlighter-rouge">a -&gt; b</code> on it), and vice versa.</p>

<p>To prove this isomorphism, we need to show that for the following two conversion functions:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fw</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">b</span> <span class="o">.</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="n">fw</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">id</span>

<span class="n">bw</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">forall</span> <span class="n">b</span> <span class="o">.</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span><span class="p">)</span>
<span class="n">bw</span> <span class="n">x</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">x</span>
</code></pre></div></div>

<p>the following two statements are both true:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fw . bw = id
bw . fw = id
</code></pre></div></div>

<p>The first one is easy:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(fw . bw) fa
= fw (bw fa)
= (bw fa) id
= bw fa id
= fmap id fa
= fa
</code></pre></div></div>

<p>and there are two steps notable in the second proof:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bw (fw g) a2b
= fmap a2b (g id)
= g (fmap a2b id) (*)
= g (a2b . id)    (**)
= g a2b
</code></pre></div></div>

<p>In <code class="language-plaintext highlighter-rouge">(*)</code> we swap <code class="language-plaintext highlighter-rouge">g</code> and <code class="language-plaintext highlighter-rouge">fmap a2b</code> when apply them to <code class="language-plaintext highlighter-rouge">id</code> in sequence.
This is because the <code class="language-plaintext highlighter-rouge">forall</code> in the polymorphic function <code class="language-plaintext highlighter-rouge">g</code>
makes it a natural transformation from functor <code class="language-plaintext highlighter-rouge">(-&gt; a)</code> to functor <code class="language-plaintext highlighter-rouge">f</code>
and ensure that the following diagram commute:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                  g
      (a -&gt; b) --------&gt; f b
         ^                ^
         |                |
fmap a2b |                | fmap a2b
         |                |
         |                |
      (a -&gt; a) --------&gt; f a
                  g
</code></pre></div></div>

<p>Commutation means the both ways from bottom left to top right are the same.
So we can swap <code class="language-plaintext highlighter-rouge">g</code> and <code class="language-plaintext highlighter-rouge">fmap a2b</code>. Also notice that the bottom left is just <code class="language-plaintext highlighter-rouge">id</code>.
The <code class="language-plaintext highlighter-rouge">(**)</code> step is an application of the <code class="language-plaintext highlighter-rouge">fmap</code> definition of functor <code class="language-plaintext highlighter-rouge">(-&gt; a)</code>,
which is just function composition <code class="language-plaintext highlighter-rouge">(.)</code>. QED.</p>

  </div>
<a class="u-url" href="/posts/2015-06-16-yoneda.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">scturtle</li>
          <li><a class="u-email" href="mailto:scturtle@gmail.com">scturtle@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>No turtles were harmed during coding.</p>
      </div>
    </div>

    <div class="social-links">
<ul class="social-media-list">
<li><a rel="me" href="https://github.com/scturtle" title="scturtle"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li>
<li><a rel="me" href="https://twitter.com/scturtle" title="scturtle"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li>
<li><a rel="me" href="https://t.me/scturtle" title="scturtle"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#telegram"></use></svg></a></li>
</ul>
</div>

  </div>

</footer>
</body>

</html>
