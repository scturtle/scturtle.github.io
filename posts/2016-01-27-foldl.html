<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>ScTurtle's Pool  - Exploring Writing foldl Using foldr </title>
    <link rel="shortcut icon" href="../images/favicon.png">
    <link rel="stylesheet" type="text/css" href="../asserts/default.css">
    <link rel="stylesheet" type="text/css" href="../asserts/highlight.css">
    <script src="../asserts/highlight.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <link href="../atom.xml" rel="alternate" title="ScTurtle's Pool" type="application/atom+xml">
  </head>
  <body>
    <div id="header">
      <div id="logo">
        <a href="../">ScTurtle's Pool</a>
      </div>
      <div id="navigation">
        <a href="../">Home</a>
        <a href="../archive.html">Archive</a>
        <a href="../tags.html">Tags</a>
        <a href="../about.html">About</a>
      </div>
    </div>

    <div id="content">
      <h1>Exploring Writing foldl Using foldr</h1>
      <div class="info">
  Posted on January 27, 2016
   on <a href="../tags/haskell.html">haskell</a> 
</div>

<p>It is widely known that left folding can be implemented by right folding. But the implementation is not so obvious. Let’s try writing one from scratch. First, we need these two extensions of GHC to make life better.</p>
<div class="highlight"><pre><code class="haskell">{-# LANGUAGE ScopedTypeVariables, PartialTypeSignatures #-}</code></pre></div>
<p>Let’s just ignore the original implementations in <code>Prelude</code> and try writing them by hand:</p>
<div class="highlight"><pre><code class="haskell">import Prelude hiding (foldr, foldl)

foldr :: (b -> a -> a) -> a -> [b] -> a
foldr _ r [] = r
foldr f r (x:xs) = f x (foldr f r xs)

foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f r [] = r
foldl f a (x:xs) = foldl f (f a x) xs</code></pre></div>
<p>If we want to write <code>foldl</code> using <code>foldr</code>, that defination should looks like this:</p>
<div class="highlight"><pre><code class="haskell">foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
foldl f i bs = foldr undefined undefined undefined</code></pre></div>
<p>The only thing we can be sure is that we will still be working on list <code>bs</code>. So let’s refine the above one with this observation:</p>
<div class="highlight"><pre><code class="haskell">foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
foldl f i bs =
  let fold :: _ -> _ -> [b] -> _
      fold = foldr
  in  fold undefined undefined bs</code></pre></div>
<p>Let’s think about a small example. According to our original implantation, <code>foldl f i [b1, b2]</code> should be expanded into <code>f (f i b1) b2</code> but the form in <code>foldr g j [b1, b2]</code> is <code>g b1 (b g2 j)</code>. The most important step is the definition of <code>g</code> and <code>j</code>. The function <code>g</code> should have type looks like <code>b -&gt; r -&gt; r</code> and if the first parameter is <code>b1</code>, the second parameter (<code>r</code>) should be able to use <code>f i b1</code> in itself to re-build the original <code>foldl</code> expansion. That sounds like a continuation <code>a -&gt; r</code> instead of just <code>r</code>. Let’s try this idea:</p>
<div class="highlight"><pre><code class="haskell">foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
foldl f i bs =
  let fold :: (b -> (a -> r) -> (a -> r)) -> (a -> r) -> [b] -> (a -> r)
      fold = foldr
      g :: b -> (a -> r) -> (a -> r)
      g b1 cont = cont (f i b1)
  in  fold g undefined bs</code></pre></div>
<p>Bad thing happens. We get two type errors because now <code>g</code> and <code>fold</code> are of type ending with <code>(a -&gt; r)</code>. Let’s look into them one by one. For <code>g</code>, we are using a <code>b</code> to turn a continuation into another continuation. So <code>g</code> actually need a extra parameter <code>a</code>. And <code>fold</code> return a continuation and need an initial value <code>a</code> to get the final result. Let’s refine the signature and definition:</p>
<div class="highlight"><pre><code class="haskell">foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
foldl f i bs =
  let fold :: (b -> (a -> r) -> (a -> r)) -> (a -> r) -> [b] -> (a -> r)
      fold = foldr
      g :: b -> (a -> r) -> (a -> r)
      g b1 cont a = cont (f i b1)
  in  fold g undefined bs undefined</code></pre></div>
<p>Now our compiler warns us that <code>a</code> is not used. According to its type, the only place to use it is where <code>i</code> is. This makes sense because we are using the future result in our computation. But where <code>i</code> should go? The only place seems to using it to complete our <code>fold</code>. (I think this is the only tricky part and hope to find better thoughts on this in the future.) Let’s refine it again:</p>
<div class="highlight"><pre><code class="haskell">foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
foldl f i bs =
  let fold :: (b -> (a -> r) -> (a -> r)) -> (a -> r) -> [b] -> (a -> r)
      fold = foldr
      g :: b -> (a -> r) -> (a -> r)
      g b1 cont a = cont (f a b1)
  in  fold g undefined bs i</code></pre></div>
<p>We are almost done and only one <code>undefined</code> is left. Notice that the final result is of type <code>r</code> but our target type is <code>a</code>. That just means <code>r</code> is <code>a</code>. So the only left <code>undefined</code> is of type <code>forall a. a -&gt; a</code> and its only implantation is <code>id</code> according to parametricity. This also fits our experience with continuation by finishing it with <code>\a -&gt; a</code>. Our final version is:</p>
<div class="highlight"><pre><code class="haskell">foldl :: forall a b. (a -> b -> a) -> a -> [b] -> a
foldl f i bs =
  let g b1 cont a = cont (f a b1)
  in  foldr g id bs i</code></pre></div>
<p>It works!</p>
<div class="highlight"><pre><code class="haskell">λ> foldl (\r x -> r ++ [x]) [0 :: Int] [1 .. 10]
[0,1,2,3,4,5,6,7,8,9,10]</code></pre></div>

<div id="show_disqus">
  <a onclick="load_disqus();return false;" href="##">Show comments</a>
</div>
<div id="disqus_thread"></div>

<script type="text/javascript">
  function load_disqus() {
    var disqus_shortname = 'scturtlespool';
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    document.getElementById('show_disqus').style.display='none';
  };
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>

    </div>
    <div id="footer">
      <p><a href="https://github.com/scturtle/scturtle.github.io/tree/hakyll">hakyll</a> &copy;
        <script>document.write(new Date().getFullYear());</script> scturtle
      <p> <a href="mailto:scturtle@gmail.com">mail</a>,
        <a href="https://twitter.com/scturtle">twitter</a>,
        <a href="https://github.com/scturtle">github</a>,
        <a href="../atom.xml" rel="alternate" title="Recent Blogs | ScTurtle's Pool">feed</a>
    </div>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33410961-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
  </body>
</html>
